/**
 * Knowledge Graph Query Engine
 *
 * Provides search, clustering, and relationship analysis across all historical docs.
 * Loaded from knowledge-graph.json (generated by scripts/ingest-knowledge-graph.js)
 *
 * Features:
 * - Concept search and clustering
 * - Word frequency analysis
 * - Document connection mapping
 * - Timeline queries
 * - Cross-domain routing hints
 *
 * Usage:
 *   await KnowledgeGraph.load();
 *   const results = KnowledgeGraph.search('authentication');
 *   const related = KnowledgeGraph.getRelatedConcepts('User Profile');
 */

class KnowledgeGraphEngine {
  constructor() {
    this.graph = null;
    this.loaded = false;
    this.conceptIndex = new Map();
    this.documentIndex = new Map();
    this.wordIndex = new Map();
    console.log('[KnowledgeGraph] Engine initialized');
  }

  /**
   * Load knowledge graph from JSON file
   */
  async load() {
    if (this.loaded) {
      console.log('[KnowledgeGraph] Already loaded');
      return this.graph;
    }

    try {
      console.log('[KnowledgeGraph] Loading knowledge-graph.json...');
      const response = await fetch('/knowledge-graph.json');

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      this.graph = await response.json();
      console.log(`[KnowledgeGraph] Loaded ${this.graph.metadata.totalDocs} documents`);
      console.log(`[KnowledgeGraph] ${this.graph.metadata.totalConcepts} concepts indexed`);

      // Build indexes for fast queries
      this.buildIndexes();

      this.loaded = true;
      return this.graph;
    } catch (error) {
      console.error('[KnowledgeGraph] Failed to load:', error);
      throw error;
    }
  }

  /**
   * Build search indexes
   */
  buildIndexes() {
    console.log('[KnowledgeGraph] Building search indexes...');

    // Index concepts
    Object.entries(this.graph.concepts).forEach(([conceptName, conceptData]) => {
      this.conceptIndex.set(conceptName.toLowerCase(), {
        name: conceptName,
        ...conceptData
      });
    });

    // Index documents
    this.graph.documents.forEach(doc => {
      this.documentIndex.set(doc.id, doc);
    });

    // Index words
    Object.entries(this.graph.wordFrequency).forEach(([word, count]) => {
      this.wordIndex.set(word.toLowerCase(), { word, count });
    });

    console.log('[KnowledgeGraph] Indexes built successfully');
  }

  /**
   * Search for concepts, words, or documents
   */
  search(query, options = {}) {
    if (!this.loaded) {
      throw new Error('Knowledge graph not loaded. Call .load() first.');
    }

    const {
      limit = 20,
      type = 'all', // 'concepts' | 'documents' | 'words' | 'all'
      minRelevance = 0
    } = options;

    const results = {
      concepts: [],
      documents: [],
      words: [],
      metadata: {
        query,
        totalResults: 0,
        searchTime: 0
      }
    };

    const startTime = performance.now();
    const queryLower = query.toLowerCase();

    // Search concepts
    if (type === 'all' || type === 'concepts') {
      this.conceptIndex.forEach((conceptData, conceptKey) => {
        if (conceptKey.includes(queryLower)) {
          const relevance = this.calculateRelevance(queryLower, conceptKey);
          if (relevance >= minRelevance) {
            results.concepts.push({
              ...conceptData,
              relevance,
              type: 'concept'
            });
          }
        }
      });
    }

    // Search documents
    if (type === 'all' || type === 'documents') {
      this.documentIndex.forEach(doc => {
        const searchableText = `${doc.filename} ${doc.path} ${doc.content}`.toLowerCase();
        if (searchableText.includes(queryLower)) {
          const relevance = this.calculateRelevance(queryLower, searchableText);
          if (relevance >= minRelevance) {
            results.documents.push({
              ...doc,
              relevance,
              type: 'document'
            });
          }
        }
      });
    }

    // Search words
    if (type === 'all' || type === 'words') {
      this.wordIndex.forEach((wordData, wordKey) => {
        if (wordKey.includes(queryLower)) {
          const relevance = this.calculateRelevance(queryLower, wordKey);
          if (relevance >= minRelevance) {
            results.words.push({
              ...wordData,
              relevance,
              type: 'word'
            });
          }
        }
      });
    }

    // Sort by relevance
    results.concepts.sort((a, b) => b.relevance - a.relevance);
    results.documents.sort((a, b) => b.relevance - a.relevance);
    results.words.sort((a, b) => b.relevance - a.relevance);

    // Apply limit
    if (limit) {
      results.concepts = results.concepts.slice(0, limit);
      results.documents = results.documents.slice(0, limit);
      results.words = results.words.slice(0, limit);
    }

    results.metadata.totalResults =
      results.concepts.length +
      results.documents.length +
      results.words.length;

    results.metadata.searchTime = performance.now() - startTime;

    return results;
  }

  /**
   * Calculate search relevance score (0-1)
   */
  calculateRelevance(query, text) {
    // Exact match = 1.0
    if (text === query) return 1.0;

    // Starts with query = 0.8
    if (text.startsWith(query)) return 0.8;

    // Contains as whole word = 0.6
    const wordBoundary = new RegExp(`\\b${query}\\b`, 'i');
    if (wordBoundary.test(text)) return 0.6;

    // Contains as substring = 0.4
    if (text.includes(query)) return 0.4;

    // Partial match based on character overlap
    const overlap = this.calculateOverlap(query, text);
    return overlap * 0.3;
  }

  /**
   * Calculate character overlap ratio
   */
  calculateOverlap(str1, str2) {
    const shorter = str1.length < str2.length ? str1 : str2;
    const longer = str1.length < str2.length ? str2 : str1;

    let matches = 0;
    for (let char of shorter) {
      if (longer.includes(char)) matches++;
    }

    return matches / shorter.length;
  }

  /**
   * Get related concepts based on co-occurrence in documents
   */
  getRelatedConcepts(conceptName, options = {}) {
    if (!this.loaded) {
      throw new Error('Knowledge graph not loaded. Call .load() first.');
    }

    const { limit = 10, minStrength = 1 } = options;

    const concept = this.conceptIndex.get(conceptName.toLowerCase());
    if (!concept) {
      return [];
    }

    // Find all documents containing this concept
    const docIds = new Set(concept.documents);

    // Count co-occurring concepts
    const coOccurrence = new Map();

    docIds.forEach(docId => {
      const doc = this.documentIndex.get(docId);
      if (doc) {
        doc.concepts.forEach(otherConcept => {
          if (otherConcept !== conceptName) {
            const count = coOccurrence.get(otherConcept) || 0;
            coOccurrence.set(otherConcept, count + 1);
          }
        });
      }
    });

    // Convert to array and sort by strength
    const related = Array.from(coOccurrence.entries())
      .map(([name, strength]) => ({
        concept: name,
        strength,
        conceptData: this.conceptIndex.get(name.toLowerCase())
      }))
      .filter(item => item.strength >= minStrength)
      .sort((a, b) => b.strength - a.strength)
      .slice(0, limit);

    return related;
  }

  /**
   * Get document connections (what links to what)
   */
  getDocumentConnections(docId, options = {}) {
    if (!this.loaded) {
      throw new Error('Knowledge graph not loaded. Call .load() first.');
    }

    const { minStrength = 1 } = options;

    // Find outgoing connections
    const outgoing = this.graph.connections.filter(conn =>
      conn.fromDoc === docId && conn.strength >= minStrength
    );

    // Find incoming connections
    const incoming = this.graph.connections.filter(conn =>
      conn.toDoc === docId && conn.strength >= minStrength
    );

    return {
      outgoing: outgoing.map(conn => ({
        ...conn,
        document: this.documentIndex.get(conn.toDoc)
      })),
      incoming: incoming.map(conn => ({
        ...conn,
        document: this.documentIndex.get(conn.fromDoc)
      })),
      totalStrength: {
        outgoing: outgoing.reduce((sum, conn) => sum + conn.strength, 0),
        incoming: incoming.reduce((sum, conn) => sum + conn.strength, 0)
      }
    };
  }

  /**
   * Get concept cluster (group of highly related concepts)
   */
  getConceptCluster(conceptName, options = {}) {
    if (!this.loaded) {
      throw new Error('Knowledge graph not loaded. Call .load() first.');
    }

    const { depth = 2, minStrength = 2 } = options;

    const cluster = new Set([conceptName]);
    const queue = [{ concept: conceptName, level: 0 }];
    const visited = new Set();

    while (queue.length > 0) {
      const { concept, level } = queue.shift();

      if (level >= depth || visited.has(concept)) {
        continue;
      }

      visited.add(concept);

      const related = this.getRelatedConcepts(concept, {
        limit: 5,
        minStrength
      });

      related.forEach(({ concept: relatedConcept }) => {
        cluster.add(relatedConcept);
        if (level + 1 < depth) {
          queue.push({ concept: relatedConcept, level: level + 1 });
        }
      });
    }

    return Array.from(cluster);
  }

  /**
   * Get timeline entries for date range
   */
  getTimeline(options = {}) {
    if (!this.loaded) {
      throw new Error('Knowledge graph not loaded. Call .load() first.');
    }

    const { startDate, endDate, limit } = options;

    let timeline = [...this.graph.timeline];

    if (startDate) {
      const start = new Date(startDate);
      timeline = timeline.filter(entry => new Date(entry.date) >= start);
    }

    if (endDate) {
      const end = new Date(endDate);
      timeline = timeline.filter(entry => new Date(entry.date) <= end);
    }

    if (limit) {
      timeline = timeline.slice(0, limit);
    }

    return timeline.map(entry => ({
      ...entry,
      document: this.documentIndex.get(entry.document)
    }));
  }

  /**
   * Get most frequent words
   */
  getTopWords(limit = 50) {
    if (!this.loaded) {
      throw new Error('Knowledge graph not loaded. Call .load() first.');
    }

    return Array.from(this.wordIndex.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, limit);
  }

  /**
   * Get most connected concepts (highest document count)
   */
  getTopConcepts(limit = 50) {
    if (!this.loaded) {
      throw new Error('Knowledge graph not loaded. Call .load() first.');
    }

    return Array.from(this.conceptIndex.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, limit);
  }

  /**
   * Get cross-domain routing hints
   * Suggests which domain a concept/topic belongs to
   */
  getRoutingHint(query) {
    if (!this.loaded) {
      throw new Error('Knowledge graph not loaded. Call .load() first.');
    }

    const searchResults = this.search(query, { limit: 5 });

    // Analyze document paths to determine domain affinity
    const domainScores = {
      cringeproof: 0,
      calriven: 0,
      deathtodata: 0,
      soulfra: 0,
      pipelines: 0,
      voice: 0,
      reviews: 0,
      sandbox: 0
    };

    // Score concepts based on their document paths
    searchResults.concepts.forEach(concept => {
      concept.documents.forEach(docId => {
        const doc = this.documentIndex.get(docId);
        if (doc) {
          const path = doc.path.toLowerCase();

          // Check which domain folder it's in
          Object.keys(domainScores).forEach(domain => {
            if (path.includes(domain)) {
              domainScores[domain] += concept.relevance;
            }
          });
        }
      });
    });

    // Find highest scoring domain
    const sortedDomains = Object.entries(domainScores)
      .sort((a, b) => b[1] - a[1])
      .filter(([_, score]) => score > 0);

    return {
      query,
      suggestedDomain: sortedDomains[0]?.[0] || 'soulfra',
      allScores: Object.fromEntries(sortedDomains),
      confidence: sortedDomains[0]?.[1] || 0
    };
  }

  /**
   * Get summary statistics
   */
  getStats() {
    if (!this.loaded) {
      throw new Error('Knowledge graph not loaded. Call .load() first.');
    }

    return {
      ...this.graph.metadata,
      indexes: {
        concepts: this.conceptIndex.size,
        documents: this.documentIndex.size,
        words: this.wordIndex.size
      },
      connections: {
        total: this.graph.connections.length,
        averageStrength: this.graph.connections.reduce((sum, c) => sum + c.strength, 0) / this.graph.connections.length
      },
      timeline: {
        entries: this.graph.timeline.length,
        firstEntry: this.graph.timeline[0]?.date,
        lastEntry: this.graph.timeline[this.graph.timeline.length - 1]?.date
      }
    };
  }
}

// Export singleton instance
window.KnowledgeGraph = new KnowledgeGraphEngine();

console.log('[KnowledgeGraph] Module loaded. Call KnowledgeGraph.load() to initialize.');
