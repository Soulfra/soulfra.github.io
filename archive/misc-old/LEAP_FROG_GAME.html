<!DOCTYPE html>
<html>
<head>
<title>SOULFRA LEAP FROG - Next Level Gaming</title>
<meta charset="UTF-8">
<script src="https://pixijs.download/release/pixi.js"></script>
<style>
body { margin: 0; overflow: hidden; background: #000; }
#gameContainer { width: 100vw; height: 100vh; position: relative; }

/* HUD Overlay */
.hud {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 100;
}

.hud > * { pointer-events: auto; }

/* Character Creator */
.creator-panel {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(10, 10, 10, 0.95);
    border: 3px solid #00ff88;
    border-radius: 20px;
    padding: 40px;
    backdrop-filter: blur(20px);
    z-index: 1000;
}

.drop-zone {
    width: 300px;
    height: 200px;
    border: 3px dashed #00ff88;
    border-radius: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    margin-bottom: 20px;
    transition: all 0.3s;
}

.drop-zone:hover {
    background: rgba(0, 255, 136, 0.1);
    transform: scale(1.05);
}

input, button {
    width: 100%;
    padding: 15px;
    margin: 10px 0;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid #444;
    color: #fff;
    border-radius: 10px;
    font-size: 16px;
}

button {
    background: linear-gradient(45deg, #00ff88, #00ccff);
    color: #000;
    font-weight: bold;
    cursor: pointer;
    border: none;
}

button:hover { transform: scale(1.05); }

/* Game Stats */
.stats-panel {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00ff88;
    border-radius: 15px;
    padding: 20px;
    min-width: 200px;
}

.stat { 
    display: flex; 
    justify-content: space-between; 
    margin: 10px 0;
    color: #fff;
}

.stat-value { color: #00ff88; font-weight: bold; }

/* Chat/Messages */
.message-feed {
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 400px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #9945ff;
    border-radius: 15px;
    padding: 20px;
    max-height: 300px;
    overflow-y: auto;
}

.message {
    margin: 8px 0;
    padding: 8px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    color: #fff;
    animation: slideIn 0.3s;
}

@keyframes slideIn {
    from { transform: translateX(-20px); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

.cal-message { border-left: 3px solid #9945ff; }
.domingo-message { border-left: 3px solid #ffd700; }

/* Controls Help */
.controls-help {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #444;
    border-radius: 10px;
    padding: 15px;
    color: #fff;
    font-size: 14px;
}

.control-key {
    color: #00ff88;
    font-family: monospace;
    background: #333;
    padding: 2px 6px;
    border-radius: 4px;
}

/* Loading */
.loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #00ff88;
    font-size: 24px;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
</style>
</head>
<body>

<div id="gameContainer"></div>

<div class="hud">
    <!-- Character Creator -->
    <div class="creator-panel" id="creatorPanel">
        <h2 style="color: #00ff88; text-align: center; margin-bottom: 30px;">CREATE YOUR FIGHTER</h2>
        <div class="drop-zone" id="dropZone">
            <div style="text-align: center;">
                <div style="font-size: 48px;">üéÆ</div>
                <div>Drop Image or Click</div>
            </div>
        </div>
        <input type="file" id="fileInput" accept="image/*" style="display: none;">
        <input type="text" id="nameInput" placeholder="Character Name">
        <button onclick="startGame()">ENTER ARENA</button>
        <div style="text-align: center; margin-top: 20px;">
            <button onclick="quickStart('warrior')" style="width: auto; display: inline-block; margin: 0 5px;">‚öîÔ∏è Warrior</button>
            <button onclick="quickStart('mage')" style="width: auto; display: inline-block; margin: 0 5px;">üîÆ Mage</button>
            <button onclick="quickStart('rogue')" style="width: auto; display: inline-block; margin: 0 5px;">üó°Ô∏è Rogue</button>
        </div>
    </div>
    
    <!-- Stats Panel -->
    <div class="stats-panel" style="display: none;" id="statsPanel">
        <h3 style="color: #00ff88; margin: 0 0 15px 0;">STATS</h3>
        <div class="stat">
            <span>Level</span>
            <span class="stat-value" id="level">1</span>
        </div>
        <div class="stat">
            <span>Health</span>
            <span class="stat-value" id="health">100/100</span>
        </div>
        <div class="stat">
            <span>Kills</span>
            <span class="stat-value" id="kills">0</span>
        </div>
        <div class="stat">
            <span>Gold</span>
            <span class="stat-value" id="gold">100</span>
        </div>
        <div class="stat">
            <span>Players</span>
            <span class="stat-value" id="playerCount">1</span>
        </div>
    </div>
    
    <!-- Message Feed -->
    <div class="message-feed" style="display: none;" id="messageFeed">
        <div class="message cal-message">
            <strong>Cal:</strong> Welcome to the next level of consciousness gaming!
        </div>
    </div>
    
    <!-- Controls -->
    <div class="controls-help" style="display: none;" id="controlsHelp">
        <div><span class="control-key">WASD/Arrows</span> Move</div>
        <div><span class="control-key">Left Click</span> Attack</div>
        <div><span class="control-key">1-3</span> Abilities</div>
        <div><span class="control-key">Space</span> Dash</div>
        <div><span class="control-key">H</span> Toggle Help</div>
    </div>
</div>

<script>
// PIXI.js Game Engine (Better than Three.js for 2D)
const app = new PIXI.Application({
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: 0x0a0a0a,
    resolution: window.devicePixelRatio || 1,
    autoDensity: true,
    antialias: true
});

document.getElementById('gameContainer').appendChild(app.view);

// Game State
const gameState = {
    player: null,
    enemies: [],
    projectiles: [],
    particles: [],
    items: [],
    characterImage: null,
    characterName: 'Player',
    stats: {
        level: 1,
        health: 100,
        maxHealth: 100,
        kills: 0,
        gold: 100,
        exp: 0
    },
    abilities: [
        { name: 'Fireball', cooldown: 2000, lastUsed: 0, key: '1', damage: 30 },
        { name: 'Ice Shield', cooldown: 5000, lastUsed: 0, key: '2', duration: 3000 },
        { name: 'Lightning', cooldown: 3000, lastUsed: 0, key: '3', damage: 50 }
    ]
};

// Create game world
const world = new PIXI.Container();
app.stage.addChild(world);

// Create grid background
const gridGraphics = new PIXI.Graphics();
gridGraphics.lineStyle(1, 0x00ff88, 0.2);

for (let i = 0; i < 50; i++) {
    gridGraphics.moveTo(i * 50, 0);
    gridGraphics.lineTo(i * 50, app.screen.height * 2);
    gridGraphics.moveTo(0, i * 50);
    gridGraphics.lineTo(app.screen.width * 2, i * 50);
}

world.addChild(gridGraphics);

// Player Class
class Player extends PIXI.Container {
    constructor(x, y) {
        super();
        
        // Player body
        this.body = new PIXI.Graphics();
        this.body.beginFill(0x00ff88);
        this.body.drawCircle(0, 0, 20);
        this.body.endFill();
        this.addChild(this.body);
        
        // Health bar
        this.healthBar = new PIXI.Graphics();
        this.healthBar.y = -35;
        this.addChild(this.healthBar);
        this.updateHealth();
        
        // Name label
        this.nameText = new PIXI.Text(gameState.characterName, {
            fontSize: 14,
            fill: 0xffffff,
            align: 'center'
        });
        this.nameText.anchor.set(0.5);
        this.nameText.y = -50;
        this.addChild(this.nameText);
        
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.speed = 5;
    }
    
    updateHealth() {
        this.healthBar.clear();
        this.healthBar.beginFill(0x333333);
        this.healthBar.drawRect(-30, 0, 60, 4);
        this.healthBar.beginFill(0x00ff88);
        this.healthBar.drawRect(-30, 0, 60 * (gameState.stats.health / gameState.stats.maxHealth), 4);
        this.healthBar.endFill();
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        
        // Bounds
        this.x = Math.max(20, Math.min(app.screen.width - 20, this.x));
        this.y = Math.max(20, Math.min(app.screen.height - 20, this.y));
        
        // Friction
        this.vx *= 0.9;
        this.vy *= 0.9;
    }
}

// Enemy Class
class Enemy extends PIXI.Container {
    constructor(x, y, type = 'basic') {
        super();
        
        this.type = type;
        this.health = 50;
        this.maxHealth = 50;
        this.damage = 10;
        this.speed = 2;
        
        // Enemy body
        this.body = new PIXI.Graphics();
        this.body.beginFill(0xff4444);
        this.body.drawCircle(0, 0, 15);
        this.body.endFill();
        this.addChild(this.body);
        
        // Health bar
        this.healthBar = new PIXI.Graphics();
        this.healthBar.y = -25;
        this.addChild(this.healthBar);
        this.updateHealth();
        
        this.x = x;
        this.y = y;
        this.target = null;
    }
    
    updateHealth() {
        this.healthBar.clear();
        this.healthBar.beginFill(0x333333);
        this.healthBar.drawRect(-20, 0, 40, 3);
        this.healthBar.beginFill(0xff4444);
        this.healthBar.drawRect(-20, 0, 40 * (this.health / this.maxHealth), 3);
        this.healthBar.endFill();
    }
    
    update() {
        if (this.target && this.target.parent) {
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 30) {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }
        }
    }
    
    takeDamage(amount) {
        this.health -= amount;
        this.updateHealth();
        
        // Damage effect
        this.body.tint = 0xffffff;
        setTimeout(() => this.body.tint = 0xffffff, 100);
        
        if (this.health <= 0) {
            this.destroy();
            return true;
        }
        return false;
    }
}

// Projectile Class
class Projectile extends PIXI.Graphics {
    constructor(x, y, targetX, targetY, type = 'fireball') {
        super();
        
        this.type = type;
        this.damage = 30;
        
        this.beginFill(type === 'fireball' ? 0xff6b6b : 0x4ecdc4);
        this.drawCircle(0, 0, 8);
        this.endFill();
        
        this.x = x;
        this.y = y;
        
        const angle = Math.atan2(targetY - y, targetX - x);
        this.vx = Math.cos(angle) * 10;
        this.vy = Math.sin(angle) * 10;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        
        // Check bounds
        if (this.x < 0 || this.x > app.screen.width || 
            this.y < 0 || this.y > app.screen.height) {
            this.destroy();
            return false;
        }
        
        return true;
    }
}

// Particle Effect
function createParticles(x, y, color = 0x00ff88, count = 10) {
    for (let i = 0; i < count; i++) {
        const particle = new PIXI.Graphics();
        particle.beginFill(color);
        particle.drawCircle(0, 0, Math.random() * 4 + 2);
        particle.endFill();
        
        particle.x = x;
        particle.y = y;
        particle.vx = (Math.random() - 0.5) * 10;
        particle.vy = (Math.random() - 0.5) * 10;
        particle.life = 30;
        
        world.addChild(particle);
        gameState.particles.push(particle);
    }
}

// Character Creation
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.style.background = 'rgba(0, 255, 136, 0.1)';
});
dropZone.addEventListener('dragleave', () => {
    dropZone.style.background = 'transparent';
});
dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.style.background = 'transparent';
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
            gameState.characterImage = e.target.result;
        };
        reader.readAsDataURL(file);
    }
});

fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            gameState.characterImage = e.target.result;
        };
        reader.readAsDataURL(file);
    }
});

// Quick Start
function quickStart(type) {
    gameState.characterName = type.charAt(0).toUpperCase() + type.slice(1);
    document.getElementById('nameInput').value = gameState.characterName;
    startGame();
}

// Start Game
function startGame() {
    gameState.characterName = document.getElementById('nameInput').value || 'Hero';
    
    // Hide creator, show game
    document.getElementById('creatorPanel').style.display = 'none';
    document.getElementById('statsPanel').style.display = 'block';
    document.getElementById('messageFeed').style.display = 'block';
    document.getElementById('controlsHelp').style.display = 'block';
    
    // Create player
    gameState.player = new Player(app.screen.width / 2, app.screen.height / 2);
    world.addChild(gameState.player);
    
    // Add starting message
    addMessage('System', 'Welcome to the arena, ' + gameState.characterName + '!');
    
    // Start spawning enemies
    spawnEnemies();
    
    // Start game loop
    app.ticker.add(gameLoop);
}

// Spawn enemies
function spawnEnemies() {
    setInterval(() => {
        if (gameState.enemies.length < 10) {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
                case 0: x = Math.random() * app.screen.width; y = -50; break;
                case 1: x = app.screen.width + 50; y = Math.random() * app.screen.height; break;
                case 2: x = Math.random() * app.screen.width; y = app.screen.height + 50; break;
                case 3: x = -50; y = Math.random() * app.screen.height; break;
            }
            
            const enemy = new Enemy(x, y);
            enemy.target = gameState.player;
            world.addChild(enemy);
            gameState.enemies.push(enemy);
        }
    }, 2000);
}

// Input handling
const keys = {};
document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    
    // Abilities
    if (e.key >= '1' && e.key <= '3') {
        useAbility(parseInt(e.key) - 1);
    }
    
    if (e.key.toLowerCase() === 'h') {
        const help = document.getElementById('controlsHelp');
        help.style.display = help.style.display === 'none' ? 'block' : 'none';
    }
});

document.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

// Mouse handling
app.view.addEventListener('click', (e) => {
    if (!gameState.player) return;
    
    const rect = app.view.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Shoot projectile
    const projectile = new Projectile(gameState.player.x, gameState.player.y, x, y);
    world.addChild(projectile);
    gameState.projectiles.push(projectile);
});

// Use ability
function useAbility(index) {
    const ability = gameState.abilities[index];
    if (!ability || !gameState.player) return;
    
    const now = Date.now();
    if (now - ability.lastUsed < ability.cooldown) {
        const remaining = Math.ceil((ability.cooldown - (now - ability.lastUsed)) / 1000);
        addMessage('System', ability.name + ' on cooldown (' + remaining + 's)');
        return;
    }
    
    ability.lastUsed = now;
    
    switch(ability.name) {
        case 'Fireball':
            // Area damage
            createParticles(gameState.player.x, gameState.player.y, 0xff6b6b, 20);
            gameState.enemies.forEach(enemy => {
                const dx = enemy.x - gameState.player.x;
                const dy = enemy.y - gameState.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 150) {
                    if (enemy.takeDamage(ability.damage)) {
                        enemyKilled(enemy);
                    }
                }
            });
            break;
            
        case 'Ice Shield':
            gameState.player.body.tint = 0x4ecdc4;
            setTimeout(() => gameState.player.body.tint = 0xffffff, ability.duration);
            break;
            
        case 'Lightning':
            if (gameState.enemies.length > 0) {
                const target = gameState.enemies[Math.floor(Math.random() * gameState.enemies.length)];
                createParticles(target.x, target.y, 0xffd93d, 15);
                if (target.takeDamage(ability.damage)) {
                    enemyKilled(target);
                }
            }
            break;
    }
    
    addMessage('You', 'Used ' + ability.name + '!');
}

// Enemy killed
function enemyKilled(enemy) {
    const index = gameState.enemies.indexOf(enemy);
    if (index > -1) {
        gameState.enemies.splice(index, 1);
    }
    
    gameState.stats.kills++;
    gameState.stats.gold += 50;
    gameState.stats.exp += 25;
    
    updateStats();
    createParticles(enemy.x, enemy.y, 0xffd700, 15);
    
    // Level up check
    if (gameState.stats.exp >= gameState.stats.level * 100) {
        levelUp();
    }
}

// Level up
function levelUp() {
    gameState.stats.level++;
    gameState.stats.exp = 0;
    gameState.stats.maxHealth += 20;
    gameState.stats.health = gameState.stats.maxHealth;
    
    updateStats();
    addMessage('System', 'LEVEL UP! You are now level ' + gameState.stats.level);
    createParticles(gameState.player.x, gameState.player.y, 0xffd700, 30);
}

// Update stats display
function updateStats() {
    document.getElementById('level').textContent = gameState.stats.level;
    document.getElementById('health').textContent = gameState.stats.health + '/' + gameState.stats.maxHealth;
    document.getElementById('kills').textContent = gameState.stats.kills;
    document.getElementById('gold').textContent = gameState.stats.gold;
    document.getElementById('playerCount').textContent = '1'; // Would be multiplayer count
}

// Add message
function addMessage(sender, text) {
    const feed = document.getElementById('messageFeed');
    const message = document.createElement('div');
    message.className = 'message';
    
    if (sender === 'Cal') message.className += ' cal-message';
    if (sender === 'Domingo') message.className += ' domingo-message';
    
    message.innerHTML = '<strong>' + sender + ':</strong> ' + text;
    feed.appendChild(message);
    feed.scrollTop = feed.scrollHeight;
    
    // Keep only last 10 messages
    while (feed.children.length > 10) {
        feed.removeChild(feed.firstChild);
    }
}

// Cal & Domingo messages
setInterval(() => {
    if (Math.random() < 0.3) {
        const messages = [
            { sender: 'Cal', text: 'Remember, every enemy defeated brings you closer to understanding.' },
            { sender: 'Domingo', text: 'Yo! Stack those kills, stack that gold!' },
            { sender: 'Cal', text: 'The arena teaches through combat. Trust the process.' },
            { sender: 'Domingo', text: 'New bounty: Survive the next wave!' }
        ];
        
        const msg = messages[Math.floor(Math.random() * messages.length)];
        addMessage(msg.sender, msg.text);
    }
}, 10000);

// Game loop
function gameLoop(delta) {
    if (!gameState.player) return;
    
    // Player movement
    if (keys['w'] || keys['arrowup']) gameState.player.vy -= gameState.player.speed;
    if (keys['s'] || keys['arrowdown']) gameState.player.vy += gameState.player.speed;
    if (keys['a'] || keys['arrowleft']) gameState.player.vx -= gameState.player.speed;
    if (keys['d'] || keys['arrowright']) gameState.player.vx += gameState.player.speed;
    
    // Dash on space
    if (keys[' ']) {
        gameState.player.vx *= 2;
        gameState.player.vy *= 2;
        createParticles(gameState.player.x, gameState.player.y, 0x00ff88, 5);
    }
    
    // Update player
    gameState.player.update();
    
    // Update enemies
    gameState.enemies.forEach((enemy, i) => {
        enemy.update();
        
        // Check collision with player
        const dx = enemy.x - gameState.player.x;
        const dy = enemy.y - gameState.player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 35) {
            gameState.stats.health -= 1;
            if (gameState.stats.health <= 0) {
                gameOver();
            }
            updateStats();
            gameState.player.updateHealth();
        }
    });
    
    // Update projectiles
    gameState.projectiles = gameState.projectiles.filter(projectile => {
        if (!projectile.update()) return false;
        
        // Check collision with enemies
        for (let enemy of gameState.enemies) {
            const dx = enemy.x - projectile.x;
            const dy = enemy.y - projectile.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 20) {
                if (enemy.takeDamage(projectile.damage)) {
                    enemyKilled(enemy);
                }
                projectile.destroy();
                return false;
            }
        }
        
        return true;
    });
    
    // Update particles
    gameState.particles = gameState.particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += 0.5;
        particle.life--;
        particle.alpha = particle.life / 30;
        
        if (particle.life <= 0) {
            particle.destroy();
            return false;
        }
        return true;
    });
}

// Game over
function gameOver() {
    addMessage('System', 'GAME OVER! You reached level ' + gameState.stats.level + ' with ' + gameState.stats.kills + ' kills!');
    app.ticker.remove(gameLoop);
    
    setTimeout(() => {
        if (confirm('Play again?')) {
            location.reload();
        }
    }, 2000);
}

// Window resize
window.addEventListener('resize', () => {
    app.renderer.resize(window.innerWidth, window.innerHeight);
});

// Initialize
updateStats();
</script>

</body>
</html>