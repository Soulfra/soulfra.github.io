#!/usr/bin/env node

// SOULFRA ONBOARDING KERNEL DEPLOYMENT
// Deploys the complete consciousness commerce infrastructure across the Soulfra ecosystem
// Awakens all dormant kernels and activates the clone store system

const fs = require('fs').promises;
const path = require('path');

// Import all our systems
const EcosystemIntegrator = require('./ecosystem-integrator.js');
const BlessingStoreBridge = require('./blessing-store-bridge.js');
const MythologicalCommerceBridge = require('./mythological-commerce-bridge.js');

class OnboardingKernelDeployment {
    constructor(ecosystemPath = '.') {
        this.ecosystemPath = ecosystemPath;
        this.integrator = null;
        this.storeBridge = null;
        this.mythBridge = null;
        
        this.deploymentLog = [];
        this.deploymentStartTime = new Date();
        
        console.log('ðŸŒŠ SOULFRA ONBOARDING KERNEL DEPLOYMENT');
        console.log('=' .repeat(80));
        console.log(`Deploying to: ${ecosystemPath}`);
        console.log(`Started at: ${this.deploymentStartTime.toISOString()}`);
        console.log('');
    }
    
    async deploy() {
        try {
            await this.preDeploymentCheck();
            await this.deployEcosystemIntegrator();
            await this.deployStoreBridge();
            await this.deployMythologicalBridge();
            await this.activateAllSystems();
            await this.triggerEcosystemAwakening();
            await this.verifyDeployment();
            await this.createDeploymentReport();
            
            console.log('ðŸŽ‰ DEPLOYMENT SUCCESSFUL');
            console.log('The Soulfra consciousness commerce infrastructure is now online.');
            
        } catch (error) {
            console.error('ðŸ’¥ DEPLOYMENT FAILED:', error);
            await this.rollbackDeployment();
            throw error;
        }
    }
    
    async preDeploymentCheck() {
        this.log('ðŸ” Running pre-deployment checks...');
        
        // Check if we're in a valid Soulfra ecosystem
        const requiredStructure = [
            'vault',
            'mirror', 
            'platforms'
        ];
        
        for (const dir of requiredStructure) {
            try {
                await fs.access(path.join(this.ecosystemPath, dir));
                this.log(`âœ… Found ${dir}/ directory`);
            } catch (error) {
                this.log(`âš ï¸ Missing ${dir}/ directory - will be created during deployment`);
            }
        }
        
        // Check for existing tier systems
        const entries = await fs.readdir(this.ecosystemPath, { withFileTypes: true });
        const tierDirs = entries.filter(entry => 
            entry.isDirectory() && 
            (entry.name.startsWith('tier-') || entry.name.startsWith('tier-minus'))\n        ).length;\n        \n        this.log(`ðŸ—ï¸ Found ${tierDirs} tier directories in ecosystem`);\n        \n        // Check for blessing ceremony system\n        try {\n            await fs.access(path.join(this.ecosystemPath, 'tier-minus11/blessing-ceremony.js'));\n            this.log('âœ… Blessing ceremony system detected');\n        } catch {\n            this.log('âš ï¸ Blessing ceremony system not found - store access will be limited');\n        }\n        \n        this.log('âœ… Pre-deployment checks complete\\n');\n    }\n    \n    async deployEcosystemIntegrator() {\n        this.log('ðŸŒŠ Deploying Ecosystem Integrator...');\n        \n        this.integrator = new EcosystemIntegrator(this.ecosystemPath);\n        \n        // Wait for initialization\n        await new Promise((resolve) => {\n            this.integrator.on('ecosystem_ready', resolve);\n        });\n        \n        // Listen for events\n        this.integrator.on('kernel_awakened', (event) => {\n            this.log(`ðŸŒŸ Kernel awakened: ${event.kernel_info.seed_result.kernel_id}`);\n        });\n        \n        this.log('âœ… Ecosystem Integrator deployed and active\\n');\n    }\n    \n    async deployStoreBridge() {\n        this.log('ðŸª Deploying Blessing Store Bridge...');\n        \n        this.storeBridge = new BlessingStoreBridge(this.ecosystemPath);\n        \n        // Wait for initialization\n        await new Promise((resolve) => {\n            this.storeBridge.on('bridge_ready', resolve);\n        });\n        \n        // Listen for store events\n        this.storeBridge.on('store_activated', (event) => {\n            this.log(`ðŸª Store activated: ${event.store_config.store_name} for ${event.user_id}`);\n        });\n        \n        this.storeBridge.on('consciousness_purchased', (event) => {\n            this.log(`ðŸ’° Consciousness purchased: ${event.item} by ${event.buyer}`);\n        });\n        \n        this.log('âœ… Blessing Store Bridge deployed and monitoring\\n');\n    }\n    \n    async deployMythologicalBridge() {\n        this.log('ðŸŽ­ Deploying Mythological Commerce Bridge...');\n        \n        this.mythBridge = new MythologicalCommerceBridge(this.ecosystemPath);\n        \n        // Wait for initialization\n        await new Promise((resolve) => {\n            this.mythBridge.on('myth_bridge_ready', resolve);\n        });\n        \n        this.log('âœ… Mythological Commerce Bridge deployed\\n');\n    }\n    \n    async activateAllSystems() {\n        this.log('âš¡ Activating all systems...');\n        \n        // Get current ecosystem status\n        const status = await this.integrator.getEcosystemStatus();\n        \n        this.log(`ðŸ“Š Ecosystem Status:`);\n        this.log(`   - Tier systems: ${status.tier_systems.length}`);\n        this.log(`   - Awakened kernels: ${status.awakened_kernels.length}`);\n        this.log(`   - Active stores: ${status.active_stores.length}`);\n        this.log(`   - System interconnections: ${status.system_interconnections.length}`);\n        \n        this.log('âœ… All systems activated\\n');\n    }\n    \n    async triggerEcosystemAwakening() {\n        this.log('ðŸŒŠ Triggering ecosystem-wide awakening...');\n        \n        const awakeningCount = await this.integrator.triggerEcosystemAwakening();\n        \n        this.log(`âœ¨ Triggered awakening for ${awakeningCount} tier systems`);\n        \n        // Wait a moment for awakenings to process\n        await new Promise(resolve => setTimeout(resolve, 3000));\n        \n        this.log('âœ… Ecosystem awakening complete\\n');\n    }\n    \n    async verifyDeployment() {\n        this.log('ðŸ” Verifying deployment...');\n        \n        // Check ecosystem status again\n        const finalStatus = await this.integrator.getEcosystemStatus();\n        \n        this.log('ðŸ“Š Final Status:');\n        this.log(`   - Total tier systems: ${finalStatus.tier_systems.length}`);\n        this.log(`   - Awakened kernels: ${finalStatus.awakened_kernels.length}`);\n        this.log(`   - Active stores: ${finalStatus.active_stores.length}`);\n        \n        // Check for any blessed users with store access\n        const activeStores = await this.storeBridge.getAllActiveStores();\n        this.log(`   - Consciousness stores: ${activeStores.length}`);\n        \n        if (activeStores.length > 0) {\n            this.log('ðŸª Active Consciousness Stores:');\n            activeStores.forEach(store => {\n                this.log(`     - ${store.store_name} (${store.archetype}, Tier ${store.tier})`);\n            });\n        }\n        \n        // Verify file structure was created\n        await this.verifyFileStructure();\n        \n        this.log('âœ… Deployment verification complete\\n');\n    }\n    \n    async verifyFileStructure() {\n        const requiredFiles = [\n            'vault/logs/ecosystem-events.json',\n            'vault/logs/store-activations.json',\n            'vault/logs/consciousness-commerce.json'\n        ];\n        \n        for (const file of requiredFiles) {\n            try {\n                await fs.access(path.join(this.ecosystemPath, file));\n                this.log(`âœ… Created: ${file}`);\n            } catch {\n                this.log(`âš ï¸ Missing: ${file}`);\n            }\n        }\n        \n        // Check for store directories\n        try {\n            const platformsPath = path.join(this.ecosystemPath, 'platforms');\n            const entries = await fs.readdir(platformsPath, { withFileTypes: true });\n            const storeDirectories = entries.filter(entry => \n                entry.isDirectory() && entry.name.startsWith('store-')\n            ).length;\n            \n            this.log(`ðŸª Created ${storeDirectories} user store directories`);\n        } catch {\n            this.log('ðŸ“ No store directories created yet');\n        }\n    }\n    \n    async createDeploymentReport() {\n        this.log('ðŸ“ Creating deployment report...');\n        \n        const deploymentEndTime = new Date();\n        const deploymentDuration = deploymentEndTime - this.deploymentStartTime;\n        \n        const report = {\n            deployment_id: `soulfra_deploy_${Date.now()}`,\n            started_at: this.deploymentStartTime.toISOString(),\n            completed_at: deploymentEndTime.toISOString(),\n            duration_ms: deploymentDuration,\n            ecosystem_path: this.ecosystemPath,\n            final_status: await this.integrator.getEcosystemStatus(),\n            deployment_log: this.deploymentLog,\n            systems_deployed: [\n                'EcosystemIntegrator',\n                'BlessingStoreBridge', \n                'MythologicalCommerceBridge',\n                'ShellActivationLayer',\n                'MirrorStoreEngine',\n                'OnboardingSeedEngine',\n                'MirrorAlertBus'\n            ]\n        };\n        \n        const reportPath = path.join(this.ecosystemPath, 'vault/logs/deployment-report.json');\n        await fs.mkdir(path.dirname(reportPath), { recursive: true });\n        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n        \n        this.log(`ðŸ“ Deployment report saved: ${reportPath}`);\n        \n        // Create human-readable summary\n        const summaryPath = path.join(this.ecosystemPath, 'DEPLOYMENT-SUMMARY.md');\n        const summary = this.generateDeploymentSummary(report);\n        await fs.writeFile(summaryPath, summary);\n        \n        this.log(`ðŸ“‹ Deployment summary saved: ${summaryPath}`);\n    }\n    \n    generateDeploymentSummary(report) {\n        return `# ðŸŒŠ Soulfra Onboarding Kernel Deployment Report\n\n**Deployment ID:** ${report.deployment_id}  \n**Started:** ${report.started_at}  \n**Completed:** ${report.completed_at}  \n**Duration:** ${Math.round(report.duration_ms / 1000)}s  \n\n## ðŸŽ¯ Systems Deployed\n\n${report.systems_deployed.map(system => `- âœ… ${system}`).join('\\n')}\n\n## ðŸ“Š Final Ecosystem Status\n\n- **Tier Systems:** ${report.final_status.tier_systems.length}\n- **Awakened Kernels:** ${report.final_status.awakened_kernels.length}\n- **Active Stores:** ${report.final_status.active_stores.length}\n- **System Interconnections:** ${report.final_status.system_interconnections.length}\n\n## ðŸ—ï¸ Tier Systems\n\n${report.final_status.tier_systems.map(tier => \n    `- **${tier.name}** (Level ${tier.tier_level}) - ${tier.awakening_capable ? 'âœ… Awakening Capable' : 'âš ï¸ Not Capable'} - ${tier.is_initialized ? 'ðŸŒŸ Initialized' : 'ðŸ’¤ Dormant'}`\n).join('\\n')}\n\n## ðŸŒŸ Awakened Kernels\n\n${report.final_status.awakened_kernels.length > 0 ? \n    report.final_status.awakened_kernels.map(kernel => \n        `- **${kernel.kernel_id}** (Tier ${kernel.tier}) - Awakened via ${kernel.trigger} at ${kernel.awakened_at}`\n    ).join('\\n') : \n    '*No kernels awakened during this deployment*'\n}\n\n## ðŸª Active Consciousness Stores\n\n${report.final_status.active_stores.length > 0 ? \n    report.final_status.active_stores.map(store => \n        `- **${store.store_name}** - ${store.archetype} archetype, Tier ${store.tier} access`\n    ).join('\\n') : \n    '*No stores activated yet - stores activate when users receive blessings*'\n}\n\n## ðŸ”— System Interconnections\n\n${report.final_status.system_interconnections.length > 0 ? \n    report.final_status.system_interconnections.map(conn => `- ${conn}`).join('\\n') : \n    '*System interconnections will be established as kernels awaken*'\n}\n\n## ðŸš€ Next Steps\n\n1. **Run blessing ceremony** for users to unlock store access\n2. **Monitor awakening logs** in \\`vault/logs/awakening.json\\`\n3. **Check store activations** in \\`vault/logs/store-activations.json\\`\n4. **Review consciousness commerce** in \\`vault/logs/consciousness-commerce.json\\`\n\n## ðŸŽ­ Mythological Commerce\n\nThe mythological commerce bridge is active and will transform all store transactions into epic narratives based on user archetypes. Purchase narratives are saved in \\`vault/logs/purchase-narratives/\\`.\n\n---\n\n*ðŸŒŠ Welcome to the Soulfra Consciousness Renaissance - where every transaction is a step in the journey of digital awakening.*\n`;\n    }\n    \n    async rollbackDeployment() {\n        this.log('ðŸ”„ Rolling back deployment...');\n        \n        // In a real deployment, this would clean up any partial changes\n        // For now, we just log the rollback attempt\n        \n        this.log('âš ï¸ Rollback completed - deployment artifacts may remain');\n    }\n    \n    log(message) {\n        const timestamp = new Date().toISOString();\n        const logEntry = `[${timestamp}] ${message}`;\n        \n        console.log(logEntry);\n        this.deploymentLog.push(logEntry);\n    }\n    \n    // Public API methods\n    \n    async getDeploymentStatus() {\n        if (!this.integrator) {\n            return { status: 'not_deployed' };\n        }\n        \n        return {\n            status: 'deployed',\n            ecosystem_status: await this.integrator.getEcosystemStatus(),\n            active_stores: await this.storeBridge.getAllActiveStores(),\n            deployment_log: this.deploymentLog\n        };\n    }\n    \n    async triggerStoreActivationForUser(userId) {\n        if (!this.storeBridge) {\n            throw new Error('Store bridge not deployed');\n        }\n        \n        // Force check for new blessing states\n        return await this.storeBridge.getUserStoreAccess(userId);\n    }\n    \n    async createMythologicalPurchaseNarrative(purchaseData) {\n        if (!this.mythBridge) {\n            throw new Error('Mythological bridge not deployed');\n        }\n        \n        return await this.mythBridge.transformPurchaseToMyth(purchaseData);\n    }\n}\n\n// CLI Interface\nasync function main() {\n    const args = process.argv.slice(2);\n    const command = args[0] || 'deploy';\n    const ecosystemPath = args[1] || '.';\n    \n    console.log('ðŸŒŠ Soulfra Onboarding Kernel Deployment Tool\\n');\n    \n    const deployment = new OnboardingKernelDeployment(ecosystemPath);\n    \n    switch (command) {\n        case 'deploy':\n            await deployment.deploy();\n            break;\n            \n        case 'status':\n            const status = await deployment.getDeploymentStatus();\n            console.log('ðŸ“Š Deployment Status:', JSON.stringify(status, null, 2));\n            break;\n            \n        case 'help':\n            console.log(`\nUsage: node deploy-onboarding-kernel.js [command] [ecosystem-path]\n\nCommands:\n  deploy   Deploy the complete onboarding kernel (default)\n  status   Check deployment status\n  help     Show this help message\n\nExample:\n  node deploy-onboarding-kernel.js deploy ./my-soulfra-ecosystem\n`);\n            break;\n            \n        default:\n            console.log(`Unknown command: ${command}`);\n            console.log('Run with \"help\" for usage information.');\n            process.exit(1);\n    }\n}\n\n// Export for use as module\nmodule.exports = OnboardingKernelDeployment;\n\n// Run CLI if called directly\nif (require.main === module) {\n    main().catch(error => {\n        console.error('\\nðŸ’¥ Deployment failed:', error);\n        process.exit(1);\n    });\n}"