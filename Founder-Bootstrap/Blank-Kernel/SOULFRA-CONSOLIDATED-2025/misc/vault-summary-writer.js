// Vault Summary Writer - Generates clean outputs from processed documents
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class VaultSummaryWriter {
    constructor() {
        this.outputDir = path.join(__dirname, '../vault/summaries');
        this.templates = {
            readme: this.generateReadmeTemplate(),
            overview: this.generateOverviewTemplate(),
            prompts: this.generatePromptsTemplate()
        };
        
        this.summaryMetadata = {
            created: new Date().toISOString(),
            version: '1.0.0',
            generator: 'MirrorOS Document Intake',
            calReflection: true
        };
    }
    
    async generateSummary(processedDocs, folderStructure, privacyAnalysis, reflectionData) {
        console.log('ğŸ“ Generating vault summary...');
        
        try {
            // Ensure output directory exists
            await fs.mkdir(this.outputDir, { recursive: true });
            
            // Generate all summary components
            const summary = {
                readme: await this.generateReadme(processedDocs, folderStructure, privacyAnalysis),
                overview: await this.generateOverview(processedDocs, folderStructure, privacyAnalysis, reflectionData),
                prompts: await this.generatePromptIdeas(processedDocs, reflectionData),
                metadata: this.summaryMetadata
            };
            
            // Save summary files
            await this.saveSummaryFiles(summary);
            
            return summary;
            
        } catch (error) {
            console.error('âŒ Error generating summary:', error.message);
            throw error;
        }
    }
    
    async generateReadme(processedDocs, folderStructure, privacyAnalysis) {
        const sections = [];
        
        // Title and Overview
        sections.push('# Document Vault Summary');
        sections.push('');
        sections.push(`Generated by Cal's Reflection Engine on ${new Date().toLocaleDateString()}`);
        sections.push('');
        
        // Executive Summary
        sections.push('## Overview');
        sections.push('');
        sections.push(this.generateExecutiveSummary(processedDocs, folderStructure));
        sections.push('');
        
        // Document Statistics
        sections.push('## Document Statistics');
        sections.push('');
        sections.push(this.generateStatisticsSection(processedDocs, folderStructure));
        sections.push('');
        
        // Content Analysis
        sections.push('## Content Analysis');
        sections.push('');
        sections.push(this.generateContentAnalysis(processedDocs));
        sections.push('');
        
        // Privacy Classification
        sections.push('## Privacy Classification');
        sections.push('');
        sections.push(this.generatePrivacySection(privacyAnalysis));
        sections.push('');
        
        // Document Structure
        sections.push('## Document Structure');
        sections.push('');
        sections.push('```');
        sections.push(await this.generateFolderTree(folderStructure.tree));
        sections.push('```');
        sections.push('');
        
        // Key Topics
        sections.push('## Key Topics Identified');
        sections.push('');
        sections.push(this.generateTopicsSection(processedDocs));
        sections.push('');
        
        // Recommendations
        sections.push('## Cal\'s Recommendations');
        sections.push('');
        sections.push(this.generateRecommendations(processedDocs, privacyAnalysis));
        sections.push('');
        
        // Export Options
        sections.push('## Export Options');
        sections.push('');
        sections.push(this.generateExportOptions());
        sections.push('');
        
        // Footer
        sections.push('---');
        sections.push('');
        sections.push('*This summary was generated by MirrorOS Document Intake. Content remains private unless explicitly exported.*');
        
        return sections.join('\n');
    }
    
    generateExecutiveSummary(processedDocs, folderStructure) {
        const totalDocs = processedDocs.length;
        const totalSize = folderStructure.metadata.totalSizeHuman;
        const docTypes = [...new Set(processedDocs.map(doc => doc.extension))].length;
        
        const dominantTone = this.calculateDominantTone(processedDocs);
        const avgReadability = this.calculateAverageReadability(processedDocs);
        
        const summary = [
            `This vault contains **${totalDocs} documents** totaling **${totalSize}** across **${docTypes} different file types**.`,
            '',
            `The content exhibits a predominantly **${dominantTone}** tone with ${avgReadability} readability.`,
            '',
            'Cal has analyzed the documents and identified patterns that suggest this collection would be well-suited for:'
        ];
        
        // Add use case suggestions
        const useCases = this.suggestUseCases(processedDocs);
        useCases.forEach(useCase => {
            summary.push(`- ${useCase}`);
        });
        
        return summary.join('\n');
    }
    
    generateStatisticsSection(processedDocs, folderStructure) {
        const stats = [];
        
        // File type distribution
        stats.push('### File Type Distribution');
        stats.push('');
        
        const typeDistribution = folderStructure.metadata.fileTypeDistribution;
        const sortedTypes = Object.entries(typeDistribution)
            .sort((a, b) => b[1].count - a[1].count)
            .slice(0, 10);
        
        stats.push('| File Type | Count | Total Size | Avg Size |');
        stats.push('|-----------|-------|------------|----------|');
        
        sortedTypes.forEach(([ext, data]) => {
            stats.push(`| ${ext} | ${data.count} | ${data.totalSizeHuman} | ${data.avgSizeHuman} |`);
        });
        
        stats.push('');
        
        // Content metrics
        stats.push('### Content Metrics');
        stats.push('');
        
        const totalWords = processedDocs.reduce((sum, doc) => sum + (doc.metadata?.wordCount || 0), 0);
        const totalLines = processedDocs.reduce((sum, doc) => sum + (doc.metadata?.lineCount || 0), 0);
        const avgWords = Math.round(totalWords / processedDocs.length);
        
        stats.push(`- **Total Words:** ${totalWords.toLocaleString()}`);
        stats.push(`- **Total Lines:** ${totalLines.toLocaleString()}`);
        stats.push(`- **Average Words per Document:** ${avgWords.toLocaleString()}`);
        stats.push(`- **Folder Depth:** ${folderStructure.metadata.maxDepth} levels`);
        
        return stats.join('\n');
    }
    
    generateContentAnalysis(processedDocs) {
        const analysis = [];
        
        // Tone analysis
        analysis.push('### Tone Analysis');
        analysis.push('');
        
        const toneDistribution = this.analyzeToneDistribution(processedDocs);
        analysis.push('| Tone | Documents | Percentage |');
        analysis.push('|------|-----------|------------|');
        
        Object.entries(toneDistribution)
            .sort((a, b) => b[1] - a[1])
            .forEach(([tone, count]) => {
                const percentage = ((count / processedDocs.length) * 100).toFixed(1);
                analysis.push(`| ${this.capitalize(tone)} | ${count} | ${percentage}% |`);
            });
        
        analysis.push('');
        
        // Language detection
        analysis.push('### Language Distribution');
        analysis.push('');
        
        const langDistribution = this.analyzeLanguageDistribution(processedDocs);
        const primaryLang = Object.entries(langDistribution)
            .sort((a, b) => b[1] - a[1])[0];
        
        analysis.push(`Primary language: **${this.capitalize(primaryLang[0])}** (${((primaryLang[1] / processedDocs.length) * 100).toFixed(1)}%)`);
        
        return analysis.join('\n');
    }
    
    generatePrivacySection(privacyAnalysis) {
        const privacy = [];
        
        privacy.push(`Cal has classified your documents with the following privacy levels:`);
        privacy.push('');
        
        privacy.push('| Classification | Count | Recommendation |');
        privacy.push('|----------------|-------|----------------|');
        privacy.push(`| ğŸ”´ Private | ${privacyAnalysis.summary.private} | Keep strictly confidential |`);
        privacy.push(`| ğŸŸ¡ Internal | ${privacyAnalysis.summary.internal} | Share within organization only |`);
        privacy.push(`| ğŸ”µ Restricted | ${privacyAnalysis.summary.restricted} | Limited sharing allowed |`);
        privacy.push(`| ğŸŸ¢ Public | ${privacyAnalysis.summary.public} | Safe for public sharing |`);
        
        if (privacyAnalysis.highRiskFiles.length > 0) {
            privacy.push('');
            privacy.push('âš ï¸ **High-Risk Files Detected:**');
            privacy.push('');
            privacyAnalysis.highRiskFiles.slice(0, 5).forEach(file => {
                privacy.push(`- \`${file.path}\` - ${file.findings[0]?.description || 'Sensitive content'}`);
            });
            
            if (privacyAnalysis.highRiskFiles.length > 5) {
                privacy.push(`- *...and ${privacyAnalysis.highRiskFiles.length - 5} more*`);
            }
        }
        
        return privacy.join('\n');
    }
    
    async generateFolderTree(tree, prefix = '', isLast = true) {
        let visualization = '';
        
        // Root node
        if (tree.name === '/') {
            visualization += 'ğŸ“ Document Root\n';
        } else {
            const connector = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
            const icon = tree.type === 'folder' ? 'ğŸ“' : this.getFileIcon(tree.extension);
            visualization += prefix + connector + icon + ' ' + tree.name + '\n';
        }
        
        // Process children
        if (tree.children && tree.children.length > 0) {
            const childPrefix = tree.name === '/' ? '' : prefix + (isLast ? '    ' : 'â”‚   ');
            
            // Limit display to prevent huge trees
            const displayChildren = tree.children.slice(0, 10);
            const hiddenCount = tree.children.length - displayChildren.length;
            
            for (let i = 0; i < displayChildren.length; i++) {
                const child = displayChildren[i];
                const isLastChild = i === displayChildren.length - 1 && hiddenCount === 0;
                
                visualization += await this.generateFolderTree(child, childPrefix, isLastChild);
            }
            
            if (hiddenCount > 0) {
                visualization += childPrefix + 'â””â”€â”€ ... ' + hiddenCount + ' more items\n';
            }
        }
        
        return visualization;
    }
    
    generateTopicsSection(processedDocs) {
        const topics = [];
        
        // Aggregate topics from all documents
        const topicFrequency = {};
        
        processedDocs.forEach(doc => {
            if (doc.analysis?.topics) {
                doc.analysis.topics.forEach(topic => {
                    const key = topic.word.toLowerCase();
                    topicFrequency[key] = (topicFrequency[key] || 0) + topic.count;
                });
            }
        });
        
        // Get top topics
        const topTopics = Object.entries(topicFrequency)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 20)
            .map(([word, count]) => ({ word, count }));
        
        // Group topics by theme
        const themes = this.groupTopicsByTheme(topTopics);
        
        Object.entries(themes).forEach(([theme, words]) => {
            if (words.length > 0) {
                topics.push(`### ${theme}`);
                topics.push(words.map(w => `\`${w.word}\``).join(', '));
                topics.push('');
            }
        });
        
        return topics.join('\n');
    }
    
    generateRecommendations(processedDocs, privacyAnalysis) {
        const recommendations = [];
        
        // Analyze content patterns
        const hasTechnicalDocs = processedDocs.some(doc => 
            doc.analysis?.tone?.scores?.technical > 0.5
        );
        const hasEducationalContent = processedDocs.some(doc => 
            doc.analysis?.tone?.scores?.educational > 0.5
        );
        const hasBusinessDocs = processedDocs.some(doc => 
            doc.analysis?.topics?.some(t => 
                ['business', 'strategy', 'revenue', 'customer'].includes(t.word.toLowerCase())
            )
        );
        
        recommendations.push('Based on my analysis of your documents, here are my recommendations:');
        recommendations.push('');
        
        // Content-based recommendations
        if (hasTechnicalDocs) {
            recommendations.push('**ğŸ”§ Technical Documentation Agent**');
            recommendations.push('Your technical content would work well as a documentation assistant that can answer questions about your codebase, APIs, or technical processes.');
            recommendations.push('');
        }
        
        if (hasEducationalContent) {
            recommendations.push('**ğŸ“š Educational Content Agent**');
            recommendations.push('Transform your educational materials into an interactive learning assistant that adapts to different learning styles.');
            recommendations.push('');
        }
        
        if (hasBusinessDocs) {
            recommendations.push('**ğŸ’¼ Business Intelligence Agent**');
            recommendations.push('Create a strategic advisor that understands your business context and can help with decision-making.');
            recommendations.push('');
        }
        
        // Privacy-based recommendations
        if (privacyAnalysis.summary.private > 0) {
            recommendations.push('**ğŸ”’ Privacy Considerations**');
            recommendations.push(`You have ${privacyAnalysis.summary.private} private documents. I recommend:`);
            recommendations.push('- Creating separate agents for public vs. private content');
            recommendations.push('- Implementing access controls on any exported agents');
            recommendations.push('- Reviewing and redacting sensitive information before sharing');
            recommendations.push('');
        }
        
        // General recommendations
        recommendations.push('**ğŸ’¡ General Suggestions**');
        recommendations.push('- Start with a focused agent that solves one specific problem well');
        recommendations.push('- Use your most structured documents as the foundation');
        recommendations.push('- Iterate based on user feedback once deployed');
        
        return recommendations.join('\n');
    }
    
    generateExportOptions() {
        const options = [];
        
        options.push('Your processed documents can be exported in the following formats:');
        options.push('');
        options.push('1. **ğŸ“„ Clean README** - Markdown summary of your content ($0 - Free)');
        options.push('2. **ğŸ¤– Prebuilt Agent** - Ready-to-deploy Cal fork with your knowledge ($9.99)');
        options.push('3. **ğŸŒ Landing Page Fork** - Public-facing documentation site ($14.99)');
        options.push('4. **ğŸ‘¥ Internal Team Mirror** - Private knowledge base for your team ($19.99)');
        options.push('5. **ğŸ“± Public Mirror with QR** - Shareable knowledge agent with viral distribution ($29.99)');
        options.push('');
        options.push('*Pricing applies only after you\'ve tested and confirmed the value of your export.*');
        
        return options.join('\n');
    }
    
    async generateOverview(processedDocs, folderStructure, privacyAnalysis, reflectionData) {
        const overview = {
            timestamp: new Date().toISOString(),
            summary: {
                totalDocuments: processedDocs.length,
                totalSize: folderStructure.metadata.totalSize,
                totalSizeHuman: folderStructure.metadata.totalSizeHuman,
                folderDepth: folderStructure.metadata.maxDepth,
                fileTypes: folderStructure.metadata.fileTypes.length
            },
            contentAnalysis: {
                dominantTone: this.calculateDominantTone(processedDocs),
                averageReadability: this.calculateAverageReadability(processedDocs),
                primaryLanguage: this.detectPrimaryLanguage(processedDocs),
                topTopics: this.extractTopTopics(processedDocs, 10)
            },
            privacySummary: {
                distribution: privacyAnalysis.summary,
                highRiskCount: privacyAnalysis.highRiskFiles.length,
                recommendedDefault: this.determineDefaultPrivacy(privacyAnalysis)
            },
            structuralAnalysis: {
                fileTypeDistribution: folderStructure.metadata.fileTypeDistribution,
                largestFile: folderStructure.metadata.largestFile,
                averageFileSize: folderStructure.metadata.avgFileSizeHuman,
                organizationScore: this.calculateOrganizationScore(folderStructure)
            },
            calReflection: reflectionData || {
                understanding: 'I\'ve analyzed your documents and identified key patterns and themes.',
                suggestions: this.generateAgentSuggestions(processedDocs),
                confidence: 0.85
            }
        };
        
        return overview;
    }
    
    async generatePromptIdeas(processedDocs, reflectionData) {
        const prompts = {
            metadata: {
                generated: new Date().toISOString(),
                totalDocuments: processedDocs.length,
                basedOn: 'content analysis and topic extraction'
            },
            categories: {},
            customPrompts: []
        };
        
        // Analyze content to generate relevant prompts
        const contentTypes = this.categorizeContent(processedDocs);
        
        // Generate prompts for each content type
        if (contentTypes.technical.length > 0) {
            prompts.categories.technical = {
                description: 'Technical and development-related queries',
                prompts: [
                    'How do I implement [specific feature] based on the documentation?',
                    'What are the best practices mentioned for [technology]?',
                    'Explain the architecture of [system/component]',
                    'What dependencies are required for [project]?',
                    'How do I troubleshoot [specific error or issue]?'
                ]
            };
        }
        
        if (contentTypes.business.length > 0) {
            prompts.categories.business = {
                description: 'Business strategy and operations queries',
                prompts: [
                    'What is our strategy for [specific area]?',
                    'How do we measure success in [department/project]?',
                    'What are the key risks identified in [area]?',
                    'Summarize the main points from [document/meeting]',
                    'What are our competitive advantages?'
                ]
            };
        }
        
        if (contentTypes.educational.length > 0) {
            prompts.categories.educational = {
                description: 'Learning and knowledge queries',
                prompts: [
                    'Explain [concept] in simple terms',
                    'What are the key takeaways from [topic]?',
                    'How does [concept A] relate to [concept B]?',
                    'What exercises can help me understand [topic]?',
                    'Create a study plan for learning [subject]'
                ]
            };
        }
        
        if (contentTypes.creative.length > 0) {
            prompts.categories.creative = {
                description: 'Creative and ideation queries',
                prompts: [
                    'Generate ideas based on [theme/concept]',
                    'How can I improve [creative work]?',
                    'What patterns emerge from [collection]?',
                    'Suggest variations on [idea/design]',
                    'What inspiration can you draw from [source]?'
                ]
            };
        }
        
        // Generate custom prompts based on specific topics
        const topTopics = this.extractTopTopics(processedDocs, 5);
        prompts.customPrompts = topTopics.map(topic => ({
            topic: topic.word,
            prompts: [
                `Tell me more about ${topic.word} from the documents`,
                `How is ${topic.word} used in this context?`,
                `What are the key points about ${topic.word}?`
            ]
        }));
        
        // Add general conversation starters
        prompts.categories.general = {
            description: 'General conversation starters',
            prompts: [
                'What are the main themes in these documents?',
                'Summarize the key insights from this collection',
                'What questions should I be asking about this content?',
                'How can I best utilize this information?',
                'What connections do you see between different documents?'
            ]
        };
        
        return prompts;
    }
    
    // Helper methods
    calculateDominantTone(processedDocs) {
        const toneScores = {};
        
        processedDocs.forEach(doc => {
            if (doc.analysis?.tone?.dominant) {
                const tone = doc.analysis.tone.dominant;
                toneScores[tone] = (toneScores[tone] || 0) + 1;
            }
        });
        
        const dominant = Object.entries(toneScores)
            .sort((a, b) => b[1] - a[1])[0];
        
        return dominant ? dominant[0] : 'neutral';
    }
    
    calculateAverageReadability(processedDocs) {
        const readabilityScores = processedDocs
            .map(doc => doc.analysis?.readability?.level)
            .filter(level => level);
        
        if (readabilityScores.length === 0) return 'moderate';
        
        const levels = { easy: 0, moderate: 1, difficult: 2 };
        const avgScore = readabilityScores.reduce((sum, level) => 
            sum + (levels[level] || 1), 0
        ) / readabilityScores.length;
        
        if (avgScore < 0.7) return 'easy';
        if (avgScore < 1.4) return 'moderate';
        return 'difficult';
    }
    
    detectPrimaryLanguage(processedDocs) {
        const languages = {};
        
        processedDocs.forEach(doc => {
            if (doc.analysis?.language?.language) {
                const lang = doc.analysis.language.language;
                languages[lang] = (languages[lang] || 0) + 1;
            }
        });
        
        const primary = Object.entries(languages)
            .sort((a, b) => b[1] - a[1])[0];
        
        return primary ? primary[0] : 'unknown';
    }
    
    extractTopTopics(processedDocs, limit = 10) {
        const topicFrequency = {};
        
        processedDocs.forEach(doc => {
            if (doc.analysis?.topics) {
                doc.analysis.topics.forEach(topic => {
                    const key = topic.word.toLowerCase();
                    topicFrequency[key] = (topicFrequency[key] || 0) + topic.count;
                });
            }
        });
        
        return Object.entries(topicFrequency)
            .sort((a, b) => b[1] - a[1])
            .slice(0, limit)
            .map(([word, count]) => ({ word, count }));
    }
    
    determineDefaultPrivacy(privacyAnalysis) {
        const { summary } = privacyAnalysis;
        
        if (summary.private > summary.public) return 'private';
        if (summary.internal > summary.public) return 'internal';
        if (summary.restricted > summary.public) return 'restricted';
        return 'public';
    }
    
    calculateOrganizationScore(folderStructure) {
        // Simple organization score based on structure
        const { maxDepth, totalFolders, totalFiles } = folderStructure.metadata;
        
        if (maxDepth === 0) return 0.2; // All files in root
        if (totalFolders === 0) return 0.1; // No organization
        
        const avgFilesPerFolder = totalFiles / Math.max(totalFolders, 1);
        const depthScore = Math.min(maxDepth / 5, 1); // Optimal depth around 3-5
        const distributionScore = Math.min(avgFilesPerFolder / 10, 1); // Optimal 5-10 files per folder
        
        return (depthScore * 0.5 + distributionScore * 0.5);
    }
    
    categorizeContent(processedDocs) {
        const categories = {
            technical: [],
            business: [],
            educational: [],
            creative: [],
            personal: [],
            other: []
        };
        
        processedDocs.forEach(doc => {
            const tone = doc.analysis?.tone?.dominant;
            const topics = doc.analysis?.topics?.map(t => t.word.toLowerCase()) || [];
            
            if (tone === 'technical' || topics.some(t => 
                ['code', 'api', 'function', 'algorithm', 'database'].includes(t)
            )) {
                categories.technical.push(doc);
            } else if (tone === 'formal' || topics.some(t => 
                ['business', 'strategy', 'revenue', 'customer', 'market'].includes(t)
            )) {
                categories.business.push(doc);
            } else if (tone === 'educational' || topics.some(t => 
                ['learn', 'teach', 'guide', 'tutorial', 'example'].includes(t)
            )) {
                categories.educational.push(doc);
            } else if (tone === 'creative' || topics.some(t => 
                ['design', 'art', 'creative', 'idea', 'inspiration'].includes(t)
            )) {
                categories.creative.push(doc);
            } else if (tone === 'conversational' || tone === 'emotional') {
                categories.personal.push(doc);
            } else {
                categories.other.push(doc);
            }
        });
        
        return categories;
    }
    
    analyzeToneDistribution(processedDocs) {
        const distribution = {};
        
        processedDocs.forEach(doc => {
            if (doc.analysis?.tone?.dominant) {
                const tone = doc.analysis.tone.dominant;
                distribution[tone] = (distribution[tone] || 0) + 1;
            }
        });
        
        return distribution;
    }
    
    analyzeLanguageDistribution(processedDocs) {
        const distribution = {};
        
        processedDocs.forEach(doc => {
            if (doc.analysis?.language?.language) {
                const lang = doc.analysis.language.language;
                distribution[lang] = (distribution[lang] || 0) + 1;
            }
        });
        
        return distribution;
    }
    
    suggestUseCases(processedDocs) {
        const suggestions = [];
        const categories = this.categorizeContent(processedDocs);
        
        if (categories.technical.length > processedDocs.length * 0.3) {
            suggestions.push('Technical documentation assistant');
            suggestions.push('Code review and explanation agent');
        }
        
        if (categories.business.length > processedDocs.length * 0.3) {
            suggestions.push('Business intelligence advisor');
            suggestions.push('Strategic planning assistant');
        }
        
        if (categories.educational.length > processedDocs.length * 0.3) {
            suggestions.push('Interactive learning companion');
            suggestions.push('Study guide generator');
        }
        
        if (categories.personal.length > processedDocs.length * 0.3) {
            suggestions.push('Personal knowledge assistant');
            suggestions.push('Memoir or journal companion');
        }
        
        // Default suggestions
        if (suggestions.length === 0) {
            suggestions.push('Knowledge base assistant');
            suggestions.push('Document Q&A agent');
            suggestions.push('Content summarization tool');
        }
        
        return suggestions.slice(0, 3);
    }
    
    generateAgentSuggestions(processedDocs) {
        const categories = this.categorizeContent(processedDocs);
        const suggestions = [];
        
        // Generate specific agent suggestions based on content
        if (categories.technical.length > 0) {
            suggestions.push({
                name: 'Technical Documentation Agent',
                description: 'An agent that understands your technical documentation and can answer implementation questions',
                confidence: 0.9
            });
        }
        
        if (categories.business.length > 0) {
            suggestions.push({
                name: 'Business Strategy Agent',
                description: 'A strategic advisor that understands your business context and goals',
                confidence: 0.85
            });
        }
        
        if (categories.educational.length > 0) {
            suggestions.push({
                name: 'Learning Companion Agent',
                description: 'An educational assistant that adapts to different learning styles',
                confidence: 0.88
            });
        }
        
        // Always include a general knowledge agent
        suggestions.push({
            name: 'Knowledge Base Agent',
            description: 'A comprehensive assistant that can answer questions about all your documents',
            confidence: 0.95
        });
        
        return suggestions;
    }
    
    groupTopicsByTheme(topics) {
        const themes = {
            'Technical Concepts': [],
            'Business Terms': [],
            'Action Words': [],
            'Domain Specific': [],
            'General Topics': []
        };
        
        const technicalWords = ['code', 'api', 'function', 'database', 'server', 'algorithm', 'system'];
        const businessWords = ['business', 'strategy', 'customer', 'revenue', 'market', 'product', 'service'];
        const actionWords = ['create', 'build', 'develop', 'implement', 'analyze', 'design', 'manage'];
        
        topics.forEach(topic => {
            const word = topic.word.toLowerCase();
            
            if (technicalWords.some(tw => word.includes(tw))) {
                themes['Technical Concepts'].push(topic);
            } else if (businessWords.some(bw => word.includes(bw))) {
                themes['Business Terms'].push(topic);
            } else if (actionWords.some(aw => word.includes(aw))) {
                themes['Action Words'].push(topic);
            } else if (topic.count > 20) {
                themes['Domain Specific'].push(topic);
            } else {
                themes['General Topics'].push(topic);
            }
        });
        
        return themes;
    }
    
    getFileIcon(extension) {
        const iconMap = {
            '.pdf': 'ğŸ“„',
            '.txt': 'ğŸ“',
            '.md': 'ğŸ“',
            '.doc': 'ğŸ“ƒ',
            '.docx': 'ğŸ“ƒ',
            '.json': 'ğŸ—‚ï¸',
            '.yaml': 'ğŸ—‚ï¸',
            '.yml': 'ğŸ—‚ï¸',
            '.csv': 'ğŸ“Š',
            '.html': 'ğŸŒ',
            '.htm': 'ğŸŒ',
            '.xml': 'ğŸ“‹',
            '.log': 'ğŸ“œ'
        };
        
        return iconMap[extension] || 'ğŸ“';
    }
    
    capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    
    async saveSummaryFiles(summary) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        
        // Save README
        const readmePath = path.join(this.outputDir, `README_${timestamp}.md`);
        await fs.writeFile(readmePath, summary.readme);
        console.log(`âœ… README saved to: ${readmePath}`);
        
        // Save overview JSON
        const overviewPath = path.join(this.outputDir, `vault-overview_${timestamp}.json`);
        await fs.writeFile(overviewPath, JSON.stringify(summary.overview, null, 2));
        console.log(`âœ… Overview saved to: ${overviewPath}`);
        
        // Save prompt ideas
        const promptsPath = path.join(this.outputDir, `prompt-ideas_${timestamp}.json`);
        await fs.writeFile(promptsPath, JSON.stringify(summary.prompts, null, 2));
        console.log(`âœ… Prompt ideas saved to: ${promptsPath}`);
        
        // Save latest versions without timestamp for easy access
        await fs.writeFile(path.join(this.outputDir, 'README.md'), summary.readme);
        await fs.writeFile(path.join(this.outputDir, 'vault-overview.json'), JSON.stringify(summary.overview, null, 2));
        await fs.writeFile(path.join(this.outputDir, 'prompt-ideas.json'), JSON.stringify(summary.prompts, null, 2));
    }
    
    generateReadmeTemplate() {
        return `# Document Vault Summary

Generated by Cal's Reflection Engine

## Overview
[Executive summary of document collection]

## Document Statistics
[Statistical breakdown of documents]

## Content Analysis
[Analysis of content patterns and themes]

## Privacy Classification
[Privacy levels and recommendations]

## Document Structure
[Visual folder tree]

## Key Topics Identified
[Main topics and themes]

## Cal's Recommendations
[Personalized recommendations based on content]

## Export Options
[Available export formats and pricing]

---
*This summary was generated by MirrorOS Document Intake*`;
    }
    
    generateOverviewTemplate() {
        return {
            timestamp: '',
            summary: {},
            contentAnalysis: {},
            privacySummary: {},
            structuralAnalysis: {},
            calReflection: {}
        };
    }
    
    generatePromptsTemplate() {
        return {
            metadata: {},
            categories: {},
            customPrompts: []
        };
    }
}

module.exports = VaultSummaryWriter;