<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Record Your Prediction - Soulfra</title>
  <meta name="description" content="Record a voice prediction. We'll hash it, timestamp it, and make it immutable.">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #ffffff;
      min-height: 100vh;
      padding: 2rem;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .back-link {
      display: inline-block;
      margin-bottom: 1rem;
      padding: 0.5rem 1rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      text-decoration: none;
      color: white;
      font-size: 0.875rem;
      transition: all 0.2s ease;
    }

    .back-link:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    h1 {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
    }

    .subtitle {
      font-size: 1.25rem;
      opacity: 0.9;
    }

    .recorder-card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 3rem;
      text-align: center;
      margin-bottom: 2rem;
    }

    .record-button {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff4081 0%, #ff6b9d 100%);
      border: none;
      font-size: 5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 2rem auto;
      display: block;
      box-shadow: 0 8px 30px rgba(255, 64, 129, 0.5);
    }

    .record-button:hover {
      transform: scale(1.1);
      box-shadow: 0 12px 40px rgba(255, 64, 129, 0.7);
    }

    .record-button:active {
      transform: scale(0.95);
    }

    .record-button.recording {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .timer {
      font-size: 2rem;
      font-weight: 700;
      margin: 1rem 0;
      font-family: 'Courier New', monospace;
    }

    .status {
      font-size: 1.25rem;
      margin: 1rem 0;
      opacity: 0.9;
    }

    .waveform {
      height: 80px;
      margin: 2rem 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .waveform-bar {
      width: 4px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 2px;
      transition: height 0.1s ease;
    }

    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-top: 2rem;
      flex-wrap: wrap;
    }

    .btn {
      padding: 0.875rem 2rem;
      border-radius: 8px;
      border: none;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: rgba(255, 255, 255, 0.9);
      color: #764ba2;
    }

    .btn-primary:hover {
      background: rgba(255, 255, 255, 1);
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.5);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .instructions {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 2rem;
      margin-bottom: 2rem;
    }

    .instructions h2 {
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }

    .instructions ol {
      margin-left: 1.5rem;
      line-height: 1.8;
    }

    .instructions li {
      margin-bottom: 0.5rem;
    }

    .instructions code {
      background: rgba(0, 0, 0, 0.3);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
    }

    .hidden {
      display: none;
    }

    .alert {
      padding: 1rem;
      border-radius: 8px;
      margin: 1rem 0;
    }

    .alert-success {
      background: rgba(34, 197, 94, 0.2);
      border: 1px solid rgba(34, 197, 94, 0.5);
    }

    .alert-error {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.5);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <a href="/" class="back-link">‚Üê Back to Hub</a>
      <h1>üé§ Record Your Prediction</h1>
      <p class="subtitle">Make your voice prediction immutable. We'll hash it, timestamp it, publish it.</p>
    </header>

    <div class="recorder-card">
      <button id="recordBtn" class="record-button">üéôÔ∏è</button>
      <div class="timer" id="timer">00:00</div>
      <div class="status" id="status">Click to start recording</div>

      <div class="waveform" id="waveform">
        <!-- Waveform bars will be generated here -->
      </div>

      <div class="controls">
        <button id="stopBtn" class="btn btn-secondary" disabled>‚èπ Stop Recording</button>
        <button id="downloadBtn" class="btn btn-primary hidden">‚¨áÔ∏è Download Recording</button>
        <button id="uploadBtn" class="btn btn-primary hidden" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">üöÄ Upload & Publish</button>
        <button id="resetBtn" class="btn btn-secondary hidden">üîÑ Start Over</button>
      </div>

      <div id="progress" class="hidden" style="margin-top: 1rem; text-align: center;">
        <div style="background: rgba(255,255,255,0.2); border-radius: 8px; height: 8px; overflow: hidden; margin-bottom: 0.5rem;">
          <div id="progressBar" style="background: linear-gradient(90deg, #667eea, #764ba2); height: 100%; width: 0%; transition: width 0.3s;"></div>
        </div>
        <div id="progressText" style="font-size: 0.875rem; opacity: 0.9;"></div>
      </div>

      <div id="alert" class="hidden"></div>
    </div>

    <div class="instructions">
      <h2>üìã What to Do After Recording</h2>
      <ol>
        <li>Click <strong>Download Recording</strong> to save your .webm file</li>
        <li><strong>iPhone users:</strong> AirDrop the file to your Mac</li>
        <li><strong>On Mac:</strong> Run this command:
          <br><code>python3 import_voice_memo.py ~/Downloads/your-recording.webm</code>
        </li>
        <li>Your prediction will be:
          <ul style="margin-top: 0.5rem; margin-left: 1.5rem;">
            <li>‚úÖ Transcribed automatically</li>
            <li>üîê Hashed with SHA-256</li>
            <li>üìä Routed to brand (CalRiven, DeathToData, or Soulfra)</li>
            <li>üåê Published to GitHub Pages</li>
          </ul>
        </li>
      </ol>
    </div>

    <div class="instructions">
      <h2>üí° Tips for Great Predictions</h2>
      <ul style="margin-left: 1.5rem; line-height: 1.8;">
        <li>Speak clearly and at a normal pace</li>
        <li>State what you're predicting and when you think it'll happen</li>
        <li>Include your reasoning (makes it more interesting later)</li>
        <li>Keep it under 2 minutes for best results</li>
        <li>Examples: "I predict Bitcoin will hit $100k by March 2026 because..."</li>
      </ul>
    </div>
  </div>

  <script>
    let mediaRecorder;
    let audioChunks = [];
    let startTime;
    let timerInterval;
    let audioContext;
    let analyser;
    let dataArray;
    let animationId;
    let recordedBlob = null;

    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const resetBtn = document.getElementById('resetBtn');
    const timer = document.getElementById('timer');
    const status = document.getElementById('status');
    const waveform = document.getElementById('waveform');
    const alert = document.getElementById('alert');
    const progress = document.getElementById('progress');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');

    const API_URL = 'http://localhost:5002/api/upload-voice';

    // Create waveform bars
    for (let i = 0; i < 30; i++) {
      const bar = document.createElement('div');
      bar.className = 'waveform-bar';
      bar.style.height = '4px';
      waveform.appendChild(bar);
    }

    const bars = document.querySelectorAll('.waveform-bar');

    recordBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);
    downloadBtn.addEventListener('click', downloadRecording);
    uploadBtn.addEventListener('click', uploadRecording);
    resetBtn.addEventListener('click', reset);

    // Device fingerprint
    function getDeviceFingerprint() {
      let deviceId = localStorage.getItem('soulfra_device_id');
      if (!deviceId) {
        deviceId = 'web-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('soulfra_device_id', deviceId);
      }

      return {
        local_storage_id: deviceId,
        user_agent: navigator.userAgent,
        screen_resolution: `${screen.width}x${screen.height}`,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        platform: navigator.platform
      };
    }

    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };

        mediaRecorder.onstop = () => {
          recordedBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const audioUrl = URL.createObjectURL(recordedBlob);
          downloadBtn.onclick = () => {
            const a = document.createElement('a');
            a.href = audioUrl;
            a.download = `voice-prediction-${Date.now()}.webm`;
            a.click();
          };
        };

        // Setup audio visualization
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 64;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        mediaRecorder.start();
        startTime = Date.now();

        recordBtn.classList.add('recording');
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        status.textContent = 'üî¥ Recording...';

        timerInterval = setInterval(updateTimer, 100);
        visualize();

        showAlert('Recording started! Speak your prediction.', 'success');

      } catch (err) {
        showAlert('Error: Could not access microphone. Please allow microphone access.', 'error');
        console.error('Error accessing microphone:', err);
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(track => track.stop());

        clearInterval(timerInterval);
        cancelAnimationFrame(animationId);

        recordBtn.classList.remove('recording');
        stopBtn.disabled = true;
        downloadBtn.classList.remove('hidden');
        uploadBtn.classList.remove('hidden');
        resetBtn.classList.remove('hidden');
        status.textContent = '‚úÖ Recording complete!';

        // Reset waveform
        bars.forEach(bar => bar.style.height = '4px');

        showAlert('Recording saved! Click "Upload & Publish" to publish to GitHub Pages, or "Download" to save locally.', 'success');
      }
    }

    function downloadRecording() {
      // Triggered by onclick set in onstop
      showAlert('Download started! Follow the instructions below to publish your prediction.', 'success');
    }

    async function uploadRecording() {
      if (!recordedBlob) {
        showAlert('No recording to upload', 'error');
        return;
      }

      try {
        // Show progress
        progress.classList.remove('hidden');
        uploadBtn.disabled = true;
        downloadBtn.disabled = true;

        progressBar.style.width = '10%';
        progressText.textContent = 'üì° Connecting to server...';

        // Create form data
        const formData = new FormData();
        formData.append('file', recordedBlob, `prediction-${Date.now()}.webm`);
        formData.append('fingerprint', JSON.stringify(getDeviceFingerprint()));

        progressBar.style.width = '30%';
        progressText.textContent = 'üì§ Uploading recording...';

        // Upload to API
        const response = await fetch(API_URL, {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
        }

        progressBar.style.width = '60%';
        progressText.textContent = 'üéß Transcribing with Whisper...';

        // Wait for transcription + AI debate + publish
        await new Promise(resolve => setTimeout(resolve, 2000));
        progressBar.style.width = '80%';
        progressText.textContent = 'ü§ñ Debating with AI models...';

        const result = await response.json();

        progressBar.style.width = '100%';
        progressText.textContent = '‚úÖ Published to GitHub Pages!';

        // Show success
        showAlert(`‚úÖ Published! View at: ${result.debate_url}`, 'success');

        // Add clickable link
        alert.innerHTML += `<br><a href="${result.debate_url}" target="_blank" style="color: white; text-decoration: underline; font-weight: 600;">${result.debate_url}</a>`;

        status.textContent = `‚úÖ Published as Device #${result.device_id}`;

        // Disable upload button
        uploadBtn.disabled = true;
        uploadBtn.textContent = '‚úÖ Published';

      } catch (error) {
        console.error('Upload error:', error);
        showAlert(`‚ùå Upload failed: ${error.message}`, 'error');
        uploadBtn.disabled = false;
        downloadBtn.disabled = false;
      }
    }

    function reset() {
      audioChunks = [];
      recordedBlob = null;
      timer.textContent = '00:00';
      status.textContent = 'Click to start recording';
      recordBtn.disabled = false;
      downloadBtn.classList.add('hidden');
      uploadBtn.classList.add('hidden');
      uploadBtn.disabled = false;
      uploadBtn.textContent = 'üöÄ Upload & Publish';
      resetBtn.classList.add('hidden');
      alert.classList.add('hidden');
      progress.classList.add('hidden');
      progressBar.style.width = '0%';
      bars.forEach(bar => bar.style.height = '4px');
    }

    function updateTimer() {
      const elapsed = Date.now() - startTime;
      const minutes = Math.floor(elapsed / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      timer.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function visualize() {
      analyser.getByteFrequencyData(dataArray);

      bars.forEach((bar, index) => {
        const value = dataArray[index * 2] || 0;
        const height = (value / 255) * 60 + 4;
        bar.style.height = `${height}px`;
      });

      animationId = requestAnimationFrame(visualize);
    }

    function showAlert(message, type) {
      alert.textContent = message;
      alert.className = `alert alert-${type}`;
      alert.classList.remove('hidden');
    }
  </script>
</body>
</html>
