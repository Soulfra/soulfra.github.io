<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Search & Earn VIBES - DeathToData</title>
  <meta name="description" content="Privacy-first search where you earn 0.2 VIBES per query. No tracking, no surveillance."/>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json"/>
  <link rel="icon" href="favicon.ico" type="image/x-icon"/>
  <link rel="apple-touch-icon" href="apple-touch-icon.png"/>
  <meta name="theme-color" content="#fb0044"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

  <!-- Shared Styles -->
  <link rel="stylesheet" href="assets/deathtodata.css"/>

  <style>
    /* Page-specific styles for search.html */
    .search-container {
      max-width: 900px;
      margin: 60px auto;
      padding: 0 20px;
    }

    .search-box-wrapper {
      position: relative;
      margin-bottom: 20px;
    }

    .search-box {
      width: 100%;
      padding: 18px 200px 18px 24px;
      font-size: 18px;
    }

    .voice-btn {
      position: absolute;
      right: 120px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(251, 0, 68, 0.1);
      border: 2px solid rgba(251, 0, 68, 0.3);
      color: #fb0044;
      padding: 10px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 20px;
      transition: all 0.3s ease;
      line-height: 1;
    }

    .voice-btn:hover {
      background: rgba(251, 0, 68, 0.2);
      border-color: #fb0044;
      box-shadow: 0 0 12px rgba(251, 0, 68, 0.5);
    }

    .voice-btn.recording {
      background: #fb0044;
      border-color: #fb0044;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .search-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: #fb0044;
      border: none;
      color: #000;
      padding: 10px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .search-btn:hover {
      background: #ff1a5e;
      box-shadow: 0 0 16px rgba(251, 0, 68, 0.7);
    }

    .earn-notice {
      text-align: center;
      color: #888;
      font-size: 14px;
      margin-top: 12px;
    }

    /* VIBES notification */
    .vibes-notification {
      position: fixed;
      top: 100px;
      right: 40px;
      background: rgba(251, 0, 68, 0.2);
      border: 1px solid #fb0044;
      padding: 16px 24px;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(251, 0, 68, 0.5);
      transform: translateX(400px);
      transition: transform 0.3s ease;
      z-index: 1000;
    }

    .vibes-notification.show {
      transform: translateX(0);
    }

    .vibes-notification .amount {
      font-size: 24px;
      color: #fb0044;
      font-weight: bold;
    }

    /* Results */
    .results-container {
      margin-top: 40px;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #888;
      font-size: 18px;
      display: none;
    }

    .loading.active {
      display: block;
    }

    .loading::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }

    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }

    .result-item {
      background: rgba(20, 20, 20, 0.8);
      border: 1px solid rgba(251, 0, 68, 0.2);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 16px;
      transition: all 0.3s ease;
    }

    .result-item:hover {
      border-color: rgba(251, 0, 68, 0.5);
      box-shadow: 0 0 16px rgba(251, 0, 68, 0.3);
    }

    .result-title {
      font-size: 18px;
      color: #fb0044;
      margin-bottom: 8px;
      font-weight: bold;
    }

    .result-title a {
      color: #fb0044;
      text-decoration: none;
    }

    .result-title a:hover {
      text-decoration: underline;
    }

    .result-url {
      color: #666;
      font-size: 12px;
      margin-bottom: 8px;
      word-break: break-all;
    }

    .result-snippet {
      color: #ccc;
      line-height: 1.6;
      font-size: 14px;
    }

    .no-results {
      text-align: center;
      padding: 60px 20px;
      color: #888;
    }

    .no-results h3 {
      color: #fb0044;
      font-size: 24px;
      margin-bottom: 12px;
    }

    /* Ollama Analysis */
    .ollama-section {
      margin-top: 40px;
      text-align: center;
    }

    .ask-ollama-btn {
      background: rgba(251, 0, 68, 0.1);
      border: 2px solid #fb0044;
      color: #fb0044;
      padding: 12px 32px;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 14px;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .ask-ollama-btn:hover {
      background: rgba(251, 0, 68, 0.2);
      box-shadow: 0 0 16px rgba(251, 0, 68, 0.5);
    }

    .ask-ollama-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .ollama-analysis {
      margin-top: 24px;
      padding: 24px;
      background: rgba(251, 0, 68, 0.05);
      border: 1px solid rgba(251, 0, 68, 0.3);
      border-radius: 8px;
      text-align: left;
      line-height: 1.8;
    }

    .ollama-analysis h3 {
      color: #fb0044;
      font-size: 18px;
      margin-bottom: 16px;
      font-family: 'Courier New', monospace;
    }

    .ollama-analysis p {
      color: #ccc;
      margin-bottom: 12px;
    }

    .ollama-analysis strong {
      color: #fff;
    }

    .ollama-loading {
      color: #888;
      font-size: 14px;
      margin-top: 12px;
      font-style: italic;
    }

    @media (max-width: 768px) {
      .search-box {
        padding-right: 100px;
        font-size: 16px;
      }

      .search-btn {
        padding: 8px 16px;
        font-size: 12px;
      }

      .vibes-notification {
        right: 20px;
        left: 20px;
      }
    }
  </style>
</head>
<body>

  <!-- Matrix background -->
  <canvas id="canvas"></canvas>

  <!-- Header -->
  <header>
    <a href="index.html" class="logo-link">
      <img src="logo.jpeg" alt="DeathToData" class="logo-img">
      <span class="logo-text">DEATH2DATA</span>
    </a>
    <div class="vibes-display">
      <div class="vibes-balance">
        <strong id="vibesBalance">0.0</strong> VIBES
        <span class="usd-value">($<span id="usdValue">0.00</span>)</span>
      </div>
      <button id="authBtn" class="nav-link" style="background: none; border: 1px solid rgba(251, 0, 68, 0.5); padding: 8px 16px; cursor: pointer; border-radius: 4px; transition: all 0.3s ease;">
        üîê <span id="authStatus">Authenticate</span>
      </button>
      <a href="dashboard.html" class="nav-link">Dashboard</a>
    </div>
  </header>

  <!-- Search container -->
  <div class="search-container">
    <div class="search-box-wrapper">
      <input
        type="text"
        class="search-box"
        id="searchInput"
        placeholder="Search and earn VIBES... or click üé§ to speak"
        autofocus
        autocomplete="off"
      >
      <button class="voice-btn" id="voiceBtn" title="Voice search (speak your query)">
        üé§
      </button>
      <button class="search-btn" id="searchBtn">SEARCH</button>
    </div>
    <p class="earn-notice">
      Earn <strong>+0.2 VIBES</strong> per search ¬∑ <strong>+0.3 VIBES</strong> for voice (verified human) ¬∑ Privacy-first ¬∑ No tracking
    </p>

    <!-- Loading -->
    <div class="loading" id="loading">Searching</div>

    <!-- Results -->
    <div class="results-container" id="results"></div>
  </div>

  <!-- VIBES notification -->
  <div class="vibes-notification" id="vibesNotification">
    <div class="amount">+0.2 VIBES</div>
    <div style="font-size: 14px; color: #ccc; margin-top: 4px;">Earned from search</div>
  </div>

  <!-- Footer -->
  <footer>
    <p><strong>Deal with it, Google.</strong></p>
    <p>&copy; 2026 DeathToData. Every search is a vote against surveillance capitalism.</p>
  </footer>

  <!-- Universal Auth -->
  <script src="soulfra-universal-auth.js?v=2"></script>

  <!-- Voice Search -->
  <script src="voice-search.js?v=2"></script>

  <!-- Shared JavaScript -->
  <script src="assets/deathtodata.js?v=2"></script>

  <!-- Page-specific JavaScript -->
  <script>
    // Initialize universal auth
    window.soulfraAuth = new SoulfraUniversalAuth();

    // Try to load existing identity
    const identity = window.soulfraAuth.loadIdentity();
    if (identity) {
      console.log('[DeathToData] User authenticated:', identity.userId);
      document.getElementById('authStatus').textContent = identity.userId;
      document.getElementById('authBtn').style.borderColor = '#fb0044';
    }

    // Auth button handler
    document.getElementById('authBtn').addEventListener('click', async () => {
      if (window.soulfraAuth.userId) {
        // Already authenticated - show export option
        const shouldExport = confirm('You are authenticated as ' + window.soulfraAuth.userId + '\n\nExport your identity keys for backup?');
        if (shouldExport) {
          const exported = window.soulfraAuth.exportIdentity();
          const blob = new Blob([exported], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'soulfra-identity-' + window.soulfraAuth.userId + '.json';
          a.click();
        }
      } else {
        // Generate new identity
        const btn = document.getElementById('authBtn');
        btn.disabled = true;
        btn.innerHTML = '‚è≥ Generating keys...';

        try {
          const keys = await window.soulfraAuth.generateKeyPair();
          window.soulfraAuth.storeIdentity('', ''); // Empty email/name for now

          // Register with backend
          try {
            const response = await fetch(`${API_URL}/auth/register`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                publicKey: keys.publicKey,
                userId: keys.userId
              })
            });

            const data = await response.json();
            console.log('[DeathToData] Registration:', data);
          } catch (regError) {
            console.warn('[DeathToData] Backend registration failed (continuing anyway):', regError);
          }

          document.getElementById('authStatus').textContent = keys.userId;
          btn.style.borderColor = '#fb0044';
          btn.innerHTML = 'üîê <span id="authStatus">' + keys.userId + '</span>';

          alert('‚úÖ Authenticated!\n\nYour User ID: ' + keys.userId + '\n\nThis works across all Soulfra sites.\n\nYour keys are stored locally and never sent to the server.');
        } catch (error) {
          console.error('[DeathToData] Auth failed:', error);
          alert('Failed to generate keys: ' + error.message);
          btn.innerHTML = 'üîê <span id="authStatus">Authenticate</span>';
        } finally {
          btn.disabled = false;
        }
      }
    });
  </script>

  <script>
    // Search handling
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const results = document.getElementById('results');
    const loading = document.getElementById('loading');

    // Get query from URL
    const urlParams = new URLSearchParams(window.location.search);
    const initialQuery = urlParams.get('q');
    if (initialQuery) {
      searchInput.value = initialQuery;
      performSearch(initialQuery);
    }

    // Search button
    searchBtn.addEventListener('click', () => {
      const query = searchInput.value.trim();
      if (query) {
        performSearch(query);
        updateURL(query);
      }
    });

    // Enter key
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const query = searchInput.value.trim();
        if (query) {
          performSearch(query);
          updateURL(query);
        }
      }
    });

    function updateURL(query) {
      const url = new URL(window.location);
      url.searchParams.set('q', query);
      window.history.pushState({}, '', url);
    }

    async function performSearch(query) {
      loading.classList.add('active');
      results.innerHTML = '';
      searchBtn.disabled = true;

      const startTime = Date.now();

      try {
        const response = await fetch(`${API_URL}/api/search?q=${encodeURIComponent(query)}`);

        if (!response.ok) {
          throw new Error('Search failed');
        }

        const data = await response.json();
        const searchTime = ((Date.now() - startTime) / 1000).toFixed(2);

        loading.classList.remove('active');
        searchBtn.disabled = false;

        // Award VIBES
        awardVibes(0.2);

        if (data.results && data.results.length > 0) {
          displayResults(data.results, searchTime);
        } else {
          results.innerHTML = `
            <div class="no-results">
              <h3>No results found</h3>
              <p>Try different keywords or check your spelling.</p>
            </div>
          `;
        }

      } catch (error) {
        loading.classList.remove('active');
        searchBtn.disabled = false;
        results.innerHTML = `
          <div class="no-results">
            <h3>Search Error</h3>
            <p>Could not connect to search service.</p>
            <p style="color: #fb0044; margin-top: 12px; font-size: 12px;">
              ${error.message}
            </p>
            <p style="margin-top: 12px; font-size: 12px;">
              Make sure backend is running: <code>./start-deathtodata-simple.sh</code>
            </p>
          </div>
        `;
      }
    }

    // Store last search results for Ollama analysis
    let lastSearchResults = null;
    let lastSearchQuery = null;

    function displayResults(searchResults, searchTime) {
      // Store for Ollama analysis
      lastSearchResults = searchResults;
      lastSearchQuery = searchInput.value.trim();

      const header = `<p style="text-align: center; color: #888; margin-bottom: 20px; font-size: 14px;">About ${searchResults.length} results (${searchTime}s)</p>`;
      const resultsHTML = searchResults.map(result => `
        <div class="result-item">
          <div class="result-title">
            <a href="${escapeHtml(result.url)}" target="_blank" rel="noopener noreferrer">
              ${escapeHtml(result.title || 'Untitled')}
            </a>
          </div>
          <div class="result-url">${escapeHtml(result.url)}</div>
          <div class="result-snippet">${escapeHtml(result.snippet || 'No description available.')}</div>
        </div>
      `).join('');

      // Add Ollama analysis section
      const ollamaSection = `
        <div class="ollama-section" id="ollamaSection">
          <button class="ask-ollama-btn" id="askOllamaBtn" onclick="askOllama()">
            <span>ü§ñ</span>
            <span>Ask Ollama to Explain</span>
          </button>
          <div id="ollamaAnalysis"></div>
        </div>
      `;

      results.innerHTML = header + resultsHTML + ollamaSection;
    }

    async function askOllama() {
      if (!lastSearchResults || !lastSearchQuery) {
        alert('No search results to analyze');
        return;
      }

      const btn = document.getElementById('askOllamaBtn');
      const analysisDiv = document.getElementById('ollamaAnalysis');

      btn.disabled = true;
      analysisDiv.innerHTML = '<p class="ollama-loading">ü§ñ Asking Ollama to analyze results...</p>';

      try {
        const response = await fetch(`${API_URL}/api/analyze`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            query: lastSearchQuery,
            results: lastSearchResults
          })
        });

        if (!response.ok) {
          throw new Error('Analysis failed');
        }

        const data = await response.json();

        // Format analysis with markdown-like styling
        const formattedAnalysis = formatAnalysis(data.analysis);

        analysisDiv.innerHTML = `
          <div class="ollama-analysis">
            <h3>üí¨ Ollama's Analysis</h3>
            ${formattedAnalysis}
            <p style="color: #666; font-size: 12px; margin-top: 16px; font-style: italic;">
              üíæ Analysis saved to knowledge base ¬∑ <a href="knowledge.html" style="color: #fb0044;">View all learnings</a>
            </p>
          </div>
        `;

      } catch (error) {
        analysisDiv.innerHTML = `
          <div class="ollama-analysis">
            <h3 style="color: #ff4444;">‚ö†Ô∏è Analysis Error</h3>
            <p>${error.message}</p>
            <p style="font-size: 12px; color: #666; margin-top: 12px;">
              Make sure Ollama is running: <code>ollama serve</code>
            </p>
          </div>
        `;
      } finally {
        btn.disabled = false;
      }
    }

    function formatAnalysis(text) {
      // Simple formatting: convert numbered lists and bolding
      let formatted = text
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/\n/g, '<br>');

      return `<p>${formatted}</p>`;
    }

    // ===== VOICE SEARCH =====
    const voiceBtn = document.getElementById('voiceBtn');
    const voiceSearch = new VoiceSearch();
    let isRecording = false;

    voiceBtn.addEventListener('click', async () => {
      if (!isRecording) {
        // Start recording
        try {
          await voiceSearch.startRecording();
          isRecording = true;
          voiceBtn.classList.add('recording');
          voiceBtn.textContent = '‚èπÔ∏è';
          voiceBtn.title = 'Click to stop recording';

          // Show feedback
          loading.classList.add('active');
          loading.textContent = 'Recording... speak your search query';

        } catch (err) {
          console.error('[Voice] Failed to start recording:', err);
          alert('Failed to access microphone. Please allow microphone access.');
        }

      } else {
        // Stop recording and process
        voiceBtn.disabled = true;
        loading.textContent = 'Processing voice...';

        try {
          const result = await voiceSearch.stopRecording();

          isRecording = false;
          voiceBtn.classList.remove('recording');
          voiceBtn.textContent = 'üé§';
          voiceBtn.title = 'Voice search (speak your query)';
          voiceBtn.disabled = false;

          console.log('[Voice] Result:', result);

          // Check ambient score (anti-bot)
          if (result.ambientScore < 0.7) {
            loading.classList.remove('active');
            alert(`Anti-bot check failed!\n\nAmbient score: ${result.ambientScore.toFixed(2)}\n\nYou might be in too quiet environment, or using synthetic voice.\n\nTry speaking in a normal room with some background noise.`);
            return;
          }

          // Check if we got a transcript
          if (!result.transcript || result.transcript.trim().length === 0) {
            loading.classList.remove('active');
            alert('Could not understand speech. Please try again.');
            return;
          }

          // Put transcript in search box
          searchInput.value = result.transcript;

          // Sign the voice search if authenticated
          if (window.soulfraAuth && window.soulfraAuth.userId) {
            const message = JSON.stringify({
              transcript: result.transcript,
              ambientScore: result.ambientScore,
              fingerprint: result.fingerprint,
              timestamp: Date.now()
            });

            const signature = await window.soulfraAuth.signMessage(message);

            // Send signed voice search to backend
            await fetch(`${API_URL}/api/voice-search`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                transcript: result.transcript,
                ambientScore: result.ambientScore,
                fingerprint: result.fingerprint,
                signature: signature,
                publicKey: window.soulfraAuth.publicKey
              })
            });

            console.log('[Voice] Signed voice search sent to backend');
          }

          // Execute search with transcript
          await performSearch(result.transcript);

          // Show success with ambient score
          const vibesMsg = `+0.3 VIBES\n\nVerified human!\nAmbient score: ${(result.ambientScore * 100).toFixed(0)}%`;
          setTimeout(() => {
            const notification = document.getElementById('vibesNotification');
            notification.querySelector('.amount').textContent = '+0.3 VIBES';
            notification.querySelector('div:last-child').innerHTML = `Verified human (${(result.ambientScore * 100).toFixed(0)}% score)`;
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 3000);
          }, 500);

        } catch (err) {
          console.error('[Voice] Failed to process:', err);
          loading.classList.remove('active');
          voiceBtn.classList.remove('recording');
          voiceBtn.textContent = 'üé§';
          voiceBtn.disabled = false;
          isRecording = false;
          alert('Voice search failed. Please try again.');
        }
      }
    });
  </script>

</body>
</html>
